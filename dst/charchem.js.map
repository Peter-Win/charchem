{"version":3,"file":"charchem.js","sources":["webpack:///webpack/bootstrap 629a503e0df0f339a028","webpack:///src/ChemSys.js","webpack:///src/core/ChemObj.js","webpack:///src/core/index.js","webpack:///src/core/ChemSubObj.js","webpack:///src/core/ChemAtom.js","webpack:///src/visitors/TextMaker.js","webpack:///src/Lang.js","webpack:///src/core/ChemError.js","webpack:///src/core/ElemList.js","webpack:///src/math/Point.js","webpack:///src/visitors/IsNonText.js","webpack:///src/compiler/index.js","webpack:///src/visitors/ChargeCalc.js","webpack:///src/visitors/ElemListMaker.js","webpack:///src/visitors/IsAbstract.js","webpack:///src/visitors/MassCalc.js","webpack:///src/compiler/chainSys.js","webpack:///src/compiler/preprocess.js","webpack:///src/compiler/utils.js","webpack:///src/core/ChemAgent.js","webpack:///src/core/ChemBond.js","webpack:///src/core/ChemBr.js","webpack:///src/core/ChemCharge.js","webpack:///src/core/ChemComment.js","webpack:///src/core/ChemCustom.js","webpack:///src/core/ChemExpr.js","webpack:///src/core/ChemMul.js","webpack:///src/core/ChemNode.js","webpack:///src/core/ChemNodeItem.js","webpack:///src/core/ChemOp.js","webpack:///src/core/ChemRadical.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 629a503e0df0f339a028","/**\r\n * Created by PeterWin on 27.04.2017.\r\n */\r\n'use strict'\r\n\r\nimport { MenTbl } from './core'\r\nimport { chemCompiler } from './compiler'\r\nimport ChargeCalc from './visitors/ChargeCalc'\r\nimport ChemAtom from './core/ChemAtom'\r\nimport ElemListMaker from './visitors/ElemListMaker'\r\nimport IsAbstract from './visitors/IsAbstract'\r\nimport MassCalc from './visitors/MassCalc'\r\nimport TextMaker from './visitors/TextMaker'\r\n\r\n/**\r\n * html escape\r\n * @param {string|*} txt\tIf not string, always return ''\r\n * @returns {string}\r\n */\r\nexport function esc(txt) {\r\n\treturn (typeof txt === 'string') ? txt.replace(/</g, '&lt;').replace(/>/g, '&gt;') : ''\r\n}\r\n\r\n\r\n// Extended elements list\r\nconst extElems = {\r\n\tD: new ChemAtom(1, 'D', 2)\t// Deiterium - $M(2)H\r\n}\r\n\r\n\r\nconst ChemSys = new function () {\r\n\tthis.ver = function () {\r\n\t\t// This values must be equal to version in package.json\r\n\t\treturn [1, 1, 2]\r\n\t}\r\n\tthis.verStr = function () {\r\n\t\treturn this.ver().join('.')\r\n\t}\r\n\r\n\t/**\r\n\t * Global macros map\r\n\t * @type {Object<string,Macros>}\r\n\t */\r\n\tthis.macros = {}\r\n\r\n\t// Roman numerals for the designation of charges\r\n\tthis.RomanNum = { i: 1, ii: 2, iii: 3, iv: 4, v: 5, vi: 6, vii: 7, viii: 8 }\r\n\r\n\t// Compiler\r\n\tthis.compile = chemCompiler\r\n\r\n\t/**\r\n\t * Search for an element by its symbolic designation\r\n\t * If found, then result ChemAtom, else undefined\r\n\t * @param {string} id\r\n\t * @returns {ChemAtom|undefined}\r\n\t */\r\n\tthis.findElem = id =>\r\n\t\tMenTbl[id] || extElems[id]\r\n\r\n\t// Правила для формирования HTML-представления формулы\r\n\tthis.rulesHtml = {\r\n\t\tAgentK: '<b>*</b>',\r\n\t\tItemMass: '<sup>*</sup>',\r\n\t\tItemCnt: '<sub>*</sub>',\r\n\t\tBracketCnt: '<sub>*</sub>',\r\n\t\tItemCharge: '<sup class=\"echem-item-charge\">*</sup>',\r\n\t\tColorPre: '<span style=\"color:*\">',\r\n\t\tColorPost: '</span>',\r\n\t\tNodeCharge: '<sup>*</sup>',\r\n\t\tCustom: '<i>*</i>',\r\n\t\tRadical: '*',\r\n\t\tComment: '<em>*</em>',\r\n\t\tOpComment: '<span class=\"echem-opcomment\">*</span>',\r\n\t\tOperation: '<span class=\"echem-op\">*</span>',\r\n\t\t// Правило для вывода атомной массы и номера слева от элемента. Имеет два аргумента @=масса, *=номер\r\n\t\tMassAndNum: '<span class=\"echem-mass-and-num\">@<br/>*</span>',\r\n\t\t$InvisibleBond: ' ',\t// Для вывода невидимой связи типа -0 или _(x1,N0). Можно заменить на &nbsp;\r\n\t\tMul: '*',\t// Конструкция умножения внутри агента CuSO4_*5_H2O\r\n\t\tMultiK: '*',\t// Коэффициент 5 в конструкции CuSO4*5H2O\r\n\t\t$MulChar: '∙'\t// Символ умножения. Варианты: x * × ∙\r\n\t}\r\n\t// Правила для формирования BB-кода представления формулы (для вставки в форумы)\r\n\tthis.rulesBB = {\r\n\t\tAgentK: '[b]*[/b]',\r\n\t\tItemMass: '[sup]*[/sup]',\r\n\t\tItemCnt: '[sub]*[/sub]',\r\n\t\tBracketCnt: '[sub]*[/sub]',\r\n\t\tItemCharge: '[sup]*[/sup]',\r\n\t\tColorPre: '[color=*]',\r\n\t\tColorPost: '[/color]',\r\n\t\tNodeCharge: '[sup]*[/sup]',\r\n\t\tCustom: '[i]*[/i]',\r\n\t\tRadical: '*',\r\n\t\tComment: '[i]*[/i]',\r\n\t\t// Правило для вывода атомной массы и номера слева от элемента. Имеет два аргумента @=масса, *=номер\r\n\t\tMassAndNum: '[sup]@[/sup][sub]*[/sub]',\r\n\t\t$InvisibleBond: ' ',\t// Для вывода невидимой связи типа -0 или _(x1,N0). Можно заменить на &nbsp;\r\n\t\t$MulChar: '∙'\t// Символ умножения. Варианты: x * × ∙\r\n\t}\r\n\r\n\t// Правила для текстового представления формул\r\n\tthis.rulesText = {\r\n\t\tAgentK: '*',\r\n\t\tItemCnt: '*',\r\n\t\tItemCharge: '*',\r\n\t\tNodeCharge: '*',\r\n\t\tCustom: '*',\r\n\t\tColorPre: '',\r\n\t\tColorPost: ''\r\n\t}\r\n\r\n\t/**\r\n\t * Make text\r\n\t * @param {ChemObj} formula\r\n\t * @param {Object=} rules\tDefault rules = ChemSys.rulesHtml\r\n\t * @returns {string}\r\n\t */\r\n\tthis.makeHtml = (formula, rules) => {\r\n\t\tlet visitor = new TextMaker(rules)\r\n\t\tformula.walk(visitor)\r\n\t\treturn visitor.res()\r\n\t}\r\n\r\n\t/**\r\n\t * Detect empty node\r\n\t * @param {ChemNode} node\r\n\t * @returns {boolean}\r\n\t */\r\n\tthis.isEmptyNode = node => {\r\n\t\tlet bNonEmpty = 0\r\n\t\tfunction onComment(obj) {\r\n\t\t\tif (obj.tx !== '')\r\n\t\t\t\treturn bNonEmpty = 1\r\n\t\t}\r\n\t\tfunction nonEmpty() {\r\n\t\t\treturn bNonEmpty = 1\r\n\t\t}\r\n\t\tnode.walk({\r\n\t\t\tatom: nonEmpty,\r\n\t\t\tradical: nonEmpty,\r\n\t\t\tcustom: onComment,\r\n\t\t\tcomm: onComment\r\n\t\t})\r\n\t\treturn !bNonEmpty\r\n\t} // isEmptyNode\r\n\r\n\t// Является ли указанный объект абстрактным\r\n\tthis.isAbstract = obj => {\r\n\t\tlet visitor = new IsAbstract()\r\n\t\tobj.walk(visitor)\r\n\t\treturn visitor.ok\r\n\t}\r\n\r\n\t// Высчитать общую массу указанной формулы или реагента\r\n\tthis.calcMass = obj => {\r\n\t\tlet visitor = new MassCalc()\r\n\t\tobj.walk(visitor)\r\n\t\treturn visitor.getSum()\r\n\t}\r\n\r\n\tthis.calcCharge = obj => {\r\n\t\tlet visitor = new ChargeCalc()\r\n\t\tobj.walk(visitor)\r\n\t\treturn visitor.result()\r\n\t}\r\n\r\n\t// Сформировать текстовую брутто-формулу (которую можно откомпилировать в выражение, но если нужно выражение, то лучше сразу использовать makeBrutto)\r\n\t// Коэффициент агентов не учитывается.\r\n\t// Не имеет смысла для выражений, которые содержат больше одного агента.\r\n\tthis.makeBruttoKey = (expr, ignoreCharge = false) => {\r\n\t\tlet list, listMaker = new ElemListMaker()\r\n\t\texpr.walk(listMaker)\r\n\t\tlist = listMaker.result()\r\n\t\tlist.sortByHill()\r\n\t\tif (ignoreCharge) list.charge = 0\r\n\t\treturn list.toString()\r\n\t}\r\n\r\n\tthis.makeBrutto = function (expr) {\r\n\t\tlet bruttoKey = ChemSys.makeBruttoKey(expr)\r\n\t\treturn ChemSys.compile(bruttoKey)\r\n\t}\r\n\r\n}\r\n\r\ntry {\r\n\twindow.ChemSys = ChemSys\r\n} catch (e) { /* ignore */ }\r\n\r\n\r\nexport default ChemSys\r\n\n\n\n// WEBPACK FOOTER //\n// src/ChemSys.js","/**\r\n * Base class for all chemical objects\r\n * Supports information about the position of the object in the source description (usually after the preprocessor)\r\n * Created by PeterWin on 28.04.2017.\r\n */\r\n'use strict'\r\n\r\nexport default class ChemObj\r\n{\r\n\t/**\r\n\t * @constructor\r\n\t * @param {number=} a\tStart position in description\r\n\t * @param {number=} b\tFinish position in description\r\n\t */\r\n\tconstructor(a = 0, b = 0) {\r\n\t\tthis.pA = a\r\n\t\tthis.pB = b\r\n\t}\r\n\r\n\tsetPos(start, stop) {\r\n\t\tthis.pA = start\r\n\t\tthis.pB = stop\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemObj.js","/**\r\n * Created by PeterWin on 27.04.2017.\r\n */\r\n\"use strict\"\r\n\r\nimport ChemAtom from './ChemAtom'\r\n\r\n/**\r\n * Is this koefficient abstract? For example n in -(CH₂)ₙ-\r\n * @param {number|string} n\r\n * @returns {boolean}\r\n */\r\nexport const isAbsK = n =>\r\n\ttypeof n !== 'number'\r\n\r\n/**\r\n * Standard rounding for mass value\r\n * @param {number} m\r\n * @returns {number}\r\n */\r\nexport const massRound = m =>\r\n\tMath.round(m * 1000) / 1000\r\n\r\n/*\r\n var DemoVisitor = {\r\n entityPre: 0,\r\n entityPost: 0,\r\n operation: 0,\r\n agentPre: 0,\r\n agentPost: 0,\r\n nodePre: 0,\r\n nodePost: 0,\r\n bond: 0,\r\n bracketBegin: 0,\r\n bracketEnd: 0,\r\n mul: 0,\r\n mulEnd: 0,\r\n itemPre: 0,\r\n itemPost: 0,\r\n atom: 0,\r\n custom: 0,\r\n radical: 0,\r\n comm: 0\r\n }\r\n */\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Periodic table. It is filled in automatically. Sample element description:\r\n * H: { n:1, id:'H', M:1.008}\r\n * @type {Object<string,ChemAtom>}\r\n */\r\nexport let MenTbl = {\r\n}\r\n\r\n/**\r\n * Array of chemical elements. Index = atomic number-1\r\n * 0: H,  1: He,  2: Li,  3: Be...\r\n * @type {ChemAtom[]}\r\n */\r\nexport let MenTblArray=[]\r\n\r\n!function () {\r\n\r\n\tconst MenDef = [\r\n\t\t'H,1.008', 'He,4.003',\r\n\t\t'Li,6.941', 'Be,9.0122', 'B,10.811', 'C,12.011', 'N,14.007', 'O,15.999', 'F,18.998', 'Ne,20.179',\r\n\t\t'Na,22.99','Mg,24.312','Al,26.092','Si,28.086','P,30.974','S,32.064','Cl,35.453','Ar,39.948',\r\n\t\t'K,39.102','Ca,40.08','Sc,44.956','Ti,47.956','V,50.941','Cr,51.996','Mn,54.938','Fe,55.849','Co,58.933','Ni,58.7',\r\n\t\t'Cu,63.546','Zn,65.37','Ga,69.72','Ge,72.59','As,74.922','Se,78.96','Br,79.904','Kr,83.8',\r\n\t\t'Rb,85.468','Sr,87.62','Y,88.906','Zr,91.22','Nb,92.906','Mo,95.94','Tc,99','Ru,101.07','Rh,102.906','Pd,106.4',\r\n\t\t'Ag,107.868','Cd,112.41','In,114.82','Sn,118.69','Sb,121.75','Te,127.6','I,126.905','Xe,131.3',\r\n\t\t'Cs,132.905','Ba,137.34',\r\n\t\t'La,138.906','Ce,140.115','Pr,140.908','Nd,144.24','Pm,145','Sm,150.4','Eu,151.96','Gd,157.25','Tb,158.926',\r\n\t\t'Dy,162.5','Ho,164.93','Er,167.26','Tm,168.934','Yb,173.04','Lu,174.97',\r\n\t\t'Hf,178.49','Ta,180.948','W,183.85','Re,186.207','Os,190.2','Ir,192.22','Pt,195.09',\r\n\t\t'Au,196.967','Hg,200.59','Tl,204.37','Pb,207.19','Bi,208.98','Po,210','At,210','Rn,222',\r\n\t\t'Fr,223','Ra,226',\r\n\t\t'Ac,227','Th,232.038','Pa,231','U,238.29','Np,237','Pu,244','Am,243','Cm,247','Bk,247','Cf,251','Es,254',\r\n\t\t'Fm,257','Md,258','No,259','Lr,260',\r\n\t\t'Rf,261','Db,262','Sg,271','Bh,267','Hs,269','Mt,276','Ds,281','Rg,280','Cn,285'\r\n\t]\r\n\tMenDef.forEach((descr, i) => {\r\n\t\tlet L = descr.split(',')\r\n\t\tlet atom = new ChemAtom(i+1, L[0], +L[1])\r\n\t\tMenTblArray[i] = MenTbl[L[0]] = atom\r\n\t})\r\n\r\n}()\n\n\n// WEBPACK FOOTER //\n// src/core/index.js","/**\r\n * Subordinate object for the node element\r\n * Created by PeterWin on 28.04.2017.\r\n */\r\n\r\nexport default class ChemSubObj {\r\n\t// abstract walk(visitor)\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemSubObj.js","/**\r\n * Chemical element or Atom\r\n * Created by PeterWin on 28.04.2017.\r\n */\r\n\"use strict\"\r\n\r\nimport ChemSubObj from './ChemSubObj'\r\n\r\nexport default class ChemAtom extends ChemSubObj\r\n{\r\n\t/**\r\n\t * @constructor\r\n\t * @param {int} atomicNumber\r\n\t * @param {string} id\r\n\t * @param {number} mass\r\n\t */\r\n\tconstructor(atomicNumber, id, mass) {\r\n\t\tsuper()\r\n\t\tthis.n = atomicNumber\t\t// Atomic number\r\n\t\tthis.id = id\t// Symbol of a chemical element: H, He, Li, Be...\r\n\t\tthis.M = mass\t\t// Atomic mass in Daltons\r\n\t}\r\n\r\n\t/**\r\n\t * Call 'atom' method of visitor\r\n\t * @param {Object} visitor\r\n\t */\r\n\twalk(visitor) {\r\n\t\tif (visitor.atom)\r\n\t\t\treturn visitor.atom(this);\r\n\t}\r\n}\n\n\n// WEBPACK FOOTER //\n// src/core/ChemAtom.js","/**\r\n * Created by PeterWin on 06.05.2017.\r\n */\r\n\r\nimport ChemSys from '../ChemSys'\r\n\r\nexport default function TextMaker(rules) {\r\n\trules = rules || ChemSys.rulesHtml\r\n\tif (rules === 'text')\r\n\t\trules = ChemSys.rulesText\r\n\telse if (rules === 'BB' || rules === 'bb')\r\n\t\trules = ChemSys.rulesBB\r\n\r\n\tlet me = this,\r\n\t\tstack = [{ tx:'' }],\r\n\t\tnextNodeNeg = 0,\r\n\t\tatomColor = 0,\r\n\t\tbFirst = 1\r\n\r\n\tme.res = () =>\r\n\t\tstack[0].tx\r\n\r\n\tfunction useRule(key, value) {\r\n\t\tif (!(key in rules))\r\n\t\t\treturn value\r\n\t\treturn rules[key].replace(/\\*/g, value)\r\n\t}\r\n\tfunction ctxOut(s) {\r\n\t\tstack[0].tx += s\r\n\t}\r\n\tfunction space() {\r\n\t\tif (bFirst) bFirst = 0\r\n\t\telse ctxOut(' ')\r\n\t}\r\n\r\n\tfunction ctxOutRule(rule, text) {\r\n\t\tctxOut(useRule(rule, text))\r\n\t}\r\n\tfunction setNeg() {\r\n\t\tstack[0].neg = 1\r\n\t}\r\n\tfunction pushCell() {\r\n\t\tstack.unshift({ tx:'' })\r\n\t}\r\n\tfunction popCell() {\r\n\t\tlet cell = stack.shift()\r\n\t\tif (cell.neg) {\r\n\t\t\tstack[0].tx = cell.tx + stack[0].tx\r\n\t\t} else {\r\n\t\t\tstack[0].tx += cell.tx\r\n\t\t}\r\n\t}\r\n\r\n\tme.atom = function (obj) {\r\n\t\tif (atomColor)\r\n\t\t\tctxOutRule('ColorPre', atomColor)\r\n\t\tctxOut(useRule('Atom', obj.id) )\r\n\t\tif (atomColor)\r\n\t\t\tctxOutRule('ColorPost', atomColor)\r\n\t}\r\n\tme.custom = function (obj) {\r\n\t\tctxOutRule('Custom', obj.tx)\r\n\t}\r\n\tme.comm = function (obj) {\r\n\t\tctxOutRule('Comment', obj.tx)\r\n\t}\r\n\tme.radical = function (obj) {\r\n\t\tctxOutRule('Radical', obj.label)\r\n\t}\r\n\r\n\tme.itemPre = function (obj) {\r\n\t\tif (obj.color)\r\n\t\t\tctxOutRule('ColorPre', obj.color)\r\n\t\tif (obj.atomNum) {\r\n\t\t\t// Вывести двухэтажную конструкцию: масса/атомный номер слева от элемента\r\n\t\t\tlet s = useRule('MassAndNum', obj.obj.n || '').replace('@', obj.M || '')\r\n\t\t\tctxOut(s)\r\n\t\t} else if (obj.M) {\r\n\t\t\tctxOutRule('ItemMass', obj.M)\r\n\t\t}\r\n\t\tatomColor = obj.atomColor\r\n\t}\r\n\tme.itemPost = function (obj) {\r\n\t\tif (obj.charge) {\r\n\t\t\tctxOutRule('ItemCharge', obj.charge.tx)\r\n\t\t}\r\n\t\tatomColor = 0\r\n\t\tif (obj.n !== 1) {\r\n\t\t\tctxOutRule('ItemCnt', obj.n)\r\n\t\t}\r\n\t\tif (obj.color)\r\n\t\t\tctxOutRule('ColorPost', obj.color)\r\n\t}\r\n\tme.bond = function (obj) {\r\n\t\tpushCell()\r\n\t\tif (obj.color)\r\n\t\t\tctxOutRule('ColorPre', obj.color)\r\n\t\tlet text = obj.tx\r\n\t\tif (!obj.N) text = rules.$InvisibleBond || ' '\t// Empty bond\r\n\t\tctxOut(text)\r\n\t\tif (obj.pt.x < 0) {\r\n\t\t\tsetNeg()\r\n\t\t\tnextNodeNeg = 1\r\n\t\t}\r\n\t\tif (obj.color)\r\n\t\t\tctxOutRule('ColorPost', obj.color)\r\n\t\tpopCell()\r\n\t}\r\n\r\n\tfunction drawCharge(obj, bLeft) {\r\n\t\tlet charge = obj.charge\r\n\t\tif (charge) {\r\n\t\t\tif (!(bLeft ^ charge.bLeft)) {\r\n\t\t\t\tctxOutRule('NodeCharge', charge.tx)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tme.bracketBegin = function (obj) {\r\n\t\tdrawCharge(obj.end, 1)\r\n\t\tctxOut(obj.tx)\r\n\t}\r\n\tme.bracketEnd = function (obj) {\r\n\t\tctxOut(obj.tx)\r\n\t\tif (obj.n !== 1) {\r\n\t\t\tctxOutRule('ItemCnt', obj.n)\r\n\t\t}\r\n\t\tdrawCharge(obj)\r\n\t}\r\n\tme.mul = function (obj) {\r\n\t\tctxOutRule('Mul', rules.$MulChar || '*')\r\n\t\tif (obj.n !== 1)\r\n\t\t\tctxOutRule('MultiK', obj.n)\r\n\t}\r\n\r\n\tme.nodePre = function (obj) {\r\n\t\tdrawCharge(obj, 1)\r\n\t\tpushCell()\r\n\t}\r\n\tme.nodePost = function (obj) {\r\n\t\tif (nextNodeNeg) {\r\n\t\t\tsetNeg()\r\n\t\t\tnextNodeNeg = 0\r\n\t\t}\r\n\t\tpopCell()\r\n\t\tdrawCharge(obj)\r\n\t}\r\n\tme.agentPre = function (obj) {\r\n\t\tspace()\r\n\t\tif (obj.n !== 1)\r\n\t\t\tctxOutRule('AgentK', obj.n)\r\n\t}\r\n\r\n\tme.operation = function (obj) {\r\n\t\tspace()\r\n\t\tlet comm = obj.commentPre,\r\n\t\t\ttmp = ''\r\n\t\tif (comm)\r\n\t\t\ttmp = useRule('OpComment', comm.tx)\r\n\t\ttmp += obj.dstText\r\n\t\tcomm = obj.commentPost\r\n\t\tif (comm)\r\n\t\t\ttmp += useRule('OpComment', comm.tx)\r\n\t\tctxOutRule('Operation', tmp)\r\n\t}\r\n\tme.entityPre = function () {\r\n\t\tpushCell()\r\n\t}\r\n\tme.entityPost = function () {\r\n\t\tpopCell()\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/visitors/TextMaker.js","/**\r\n * Multilanguage support\r\n * Created by PeterWin on 27.04.2017.\r\n */\r\n'use strict'\r\n\r\nconst Lang = {\r\n\t/**\r\n\t * Current language\r\n\t * Examples: en, ru - internal languages; zh, zh-TW - external (by addDict)\r\n\t * @var {string}\r\n\t */\r\n\tcurLang: 'en',\r\n\r\n\t/**\r\n\t * Browser language\r\n\t * @var {string}\r\n\t */\r\n\tnavLang: 'en',\r\n\r\n\t/**\r\n\t * Translate phrase\r\n\t * @param {string} key\r\n\t * @param {Object=} params\r\n\t * @param {string=} lang\r\n\t * @returns {string}\r\n\t */\r\n\ttr: function (key, params, lang) {\r\n\t\tlet i, k, me = this\r\n\t\tlang = (lang || me.curLang).toLowerCase()\r\n\r\n\t\t// find dictionary\r\n\t\tlet\tcurDict = me.Dict[lang]\r\n\t\tif (!curDict && (k = lang.indexOf('-')) > 0) {\r\n\t\t\tcurDict = me.Dict[lang.slice(0, k)]\r\n\t\t}\r\n\t\tcurDict = curDict || me.Dict.en\r\n\t\t// find phrase\r\n\t\tlet\tphrase = curDict[key]\r\n\t\tif (phrase === undefined)\r\n\t\t\tphrase = key\r\n\t\t// parameters\r\n\t\tif (typeof params === 'object') for (i in params)\r\n\t\t\tphrase = phrase.replace(new RegExp('\\\\[' + i + '\\\\]', 'g'), params[i])\r\n\t\treturn phrase\r\n\t},\r\n\r\n\t/**\r\n\t * Add phrases to dictionary\r\n\t * @param {Object<string,Object>} struc\t { locale1: { key1: val1, key2:val2}, locale2: {...} }\r\n\t */\r\n\taddDict: function (struc) {\r\n\t\tlet loc, srcPart, dstPart, key\r\n\t\tfor (loc in struc) {\r\n\t\t\tsrcPart = struc[loc]\r\n\t\t\tdstPart = this.Dict[loc]\r\n\t\t\tif (!dstPart) {\r\n\t\t\t\t// The simplest case - just insert src -> dst\r\n\t\t\t\tthis.Dict[loc] = srcPart\r\n\t\t\t} else {\r\n\t\t\t\t// Adding keys to an existing partition\r\n\t\t\t\tfor (key in srcPart) {\r\n\t\t\t\t\tdstPart[key] = srcPart[key]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Set current language\r\n\t * Called automatically when the library is loaded\r\n\t * @param {Object|string} config\tCan be window.navigator object OR locale string. for ex: \"zh-tw\"\r\n\t */\r\n\tinit: function (config) {\r\n\t\tif (typeof config === 'object') {\r\n\t\t\t// Chrome, FF, Opera - navigator.language\r\n\t\t\t// IE - navigator.browserLanguage and .userLanguage\r\n\t\t\tLang.navLang = config.language || config.browserLanguage || config.userLanguage || Lang.navLang\r\n\t\t\tLang.curLang = Lang.navLang\r\n\t\t} else if (typeof config === 'string') {\r\n\t\t\tLang.curLang = config\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Auto detect browser language\r\nLang.init(window.navigator)\r\n\r\nLang.Dict = {\r\n\tru: {\r\n\t\t$Native: 'Русский', $English: 'Russian',\r\n\t\t// Ошибки\r\n\t\t'Internal error: [msg]': 'Внутренняя ошибка: [msg]',\r\n\t\t'Browser does not support canvas-graphics':\r\n\t\t\t'Браузер не поддерживает canvas-графику',\r\n\t\t'Formula can not be displayed as text':\r\n\t\t\t'Формулу нельзя отобразить в текстовом виде',\r\n\t\t\"Expected '(' after [S]\":\r\n\t\t\t\" Требуется '(' после [S]\",\r\n\t\t\"Unexpected '[C]'\": \"Неверный символ '[C]' в позиции [pos]\",\r\n\t\t\"Expected '[ok]' instead of '[bad]'\":\r\n\t\t\t\"Требуется '[ok]' вместо '[bad]' в позиции [pos]\",\r\n\t\t\"Invalid character '[C]'\":\r\n\t\t\t\"Недопустимый символ '[C]' в позиции [pos]\",\r\n\t\t'Russian element character': // param: C\r\n\t\t\t\"Недопустимый русский символ '[C]'. Для описания химического элемента должны использоваться только латинские символы.\",\r\n\t\t'Non-latin element character': // param: C\r\n\t\t\t\"Недопустимый символ '[C]'. Для описания химического элемента должны использоваться только латинские символы.\",\r\n\t\t\"Unknown element character '[C]'\":\r\n\t\t\t\"Недопустимый символ '[C]' описания реагента в позиции [pos]\",\r\n\t\t\"Expected '[C]'\":\r\n\t\t\t\"Требуется '[C]' в позиции [pos]\",\r\n\t\t\"Unknown element '[Elem]'\":\r\n\t\t\t\"Ошибочный элемент '[Elem]' в позиции [pos]\",\r\n\t\t'Comment is not closed':\r\n\t\t\t'Не закрыт комментарий, начатый в позиции [pos]',\r\n\t\t'Abstract koefficient is not closed':\r\n\t\t\t'Не закрыт абстрактный коэффициент, начатый в позиции [pos]',\r\n\t\t'Abstract element is not closed':\r\n\t\t\t'Не закрыт абстрактный элемент, начатый в позиции [pos]',\r\n\t\t'Expected node declaration before charge':\r\n\t\t\t'Неизвестно, к чему нужно применить заряд в позиции [pos]',\r\n\t\t'Invalid charge declaration':\r\n\t\t\t'Ошибка в описании заряда в позиции [pos]',\r\n\t\t'It is necessary to close the bracket':\r\n\t\t\t'Необходимо закрыть скобку, открытую в позиции [pos]',\r\n\t\t'Undefined variable [name]':\r\n\t\t\t\"Не определена числовая переменная '[name]' в позиции [pos]\",\r\n\t\t\"Invalid node reference '[ref]'\":\r\n\t\t\t\"Неправильная ссылка на узел '[ref]' в позиции [pos]\",\r\n\t\t'Invalid branch close':\r\n\t\t\t'Нельзя закрыть ветку в позиции [pos], которая не открыта',\r\n\t\t'Cant close branch before bracket':\r\n\t\t\t'Нельзя закрыть ветку в позиции [pos], пока не закрыта скобка в позиции [pos0]',\r\n\t\t'Invalid bracket close':\r\n\t\t\t'Нет пары для скобки, закрытой в позиции [pos]',\r\n\t\t'It is necessary to close the branch':\r\n\t\t\t'Необходимо закрыть ветку, открытую в позиции [pos]',\r\n\t\t'Expected [must] instead of [have]':\r\n\t\t\t'Требуется [must] вместо [have] в позиции [pos]',\r\n\t\t'Invalid middle point':\r\n\t\t\t'Не используется промежуточная точка',\r\n\t\t'Cant create ring':\r\n\t\t\t'Невозможно создать кольцо',\r\n\t\t'Cant close ring':\r\n\t\t\t'Невозможно замкнуть кольцо',\r\n\t\t'Invalid version': 'Для формулы требуется CharChem версии [need] вместо [cur]',\r\n\r\n\t\t'(s)':'(тв)', '(l)':'(ж)', '(g)':'(г)', '(aq)':'(р-р)',\r\n\t\t'Periodic Table': 'Периодическая система химических элементов',\r\n\t\t'Table legend': 'Группы химических элементов',\r\n\t\tGroup: 'Группа',\r\n\t\tPeriod: 'Период',\r\n\t\tRow: 'Ряд',\r\n\t\t'[x]-block': '[x]-блок',\r\n\t\tLanthanides: 'Лантаноиды',\r\n\t\tActinides: 'Актиноиды',\r\n\t\t'Alkali metals': 'Щелочные металлы',\r\n\t\t'Alkaline earth metals': 'Щёлочноземельные металлы',\r\n\t\t'Transition metals': 'Переходные металлы',\r\n\t\t'Post transition metals': 'Постпереходные металлы',\r\n\t\tMetalloids: 'Полуметаллы',\r\n\t\t'Other nonmetals': 'Неметаллы',\r\n\t\tHalogens: 'Галогены',\r\n\t\t'Noble gases': 'Инертные газы',\r\n\t\t'Unknown props': 'Св-ва неизвестны',\r\n\t\tH:'Водород', He:'Гелий', Li:'Литий', Be:'Бериллий', B:'Бор', C:'Углерод',\r\n\t\tN:'Азот', O:'Кислород', F:'Фтор', Ne:'Неон', Na:'Натрий', Mg:'Магний',\r\n\t\tAl:'Алюминий', Si:'Кремний', P:'Фосфор', S:'Сера', Cl:'Хлор', Ar:'Аргон',\r\n\t\tK:'Калий', Ca:'Кальций', Sc:'Скандий', Ti:'Титан', V:'Ванадий', Cr:'Хром',\r\n\t\tMn:'Марганец', Fe:'Железо', Co:'Кобальт', Ni:'Никель', Cu:'Медь', Zn:'Цинк',\r\n\t\tGa:'Галлий', Ge:'Германий', As:'Мышьяк', Se:'Селен', Br:'Бром', Kr:'Криптон',\r\n\t\tRb:'Рубидий', Sr:'Стронций', Y:'Иттрий', Zr:'Цирконий', Nb:'Ниобий', Mo:'Молибден',\r\n\t\tTc:'Технеций', Ru:'Рутений', Rh:'Родий', Pd:'Палладий', Ag:'Серебро', Cd:'Кадмий',\r\n\t\tIn:'Индий', Sn:'Олово', Sb:'Сурьма', Te:'Теллур', I:'Йод', Xe:'Ксенон',\r\n\t\tCs:'Цезий', Ba:'Барий', La:'Лантан', Ce:'Церий', Pr:'Празеодим', Nd:'Неодим',\r\n\t\tPm:'Прометий', Sm:'Самарий', Eu:'Европий', Gd:'Гадолиний', Tb:'Тербий',\r\n\t\tDy:'Диспрозий', Ho:'Гольмий', Er:'Эрбий', Tm:'Тулий', Yb:'Иттербий', Lu:'Лютеций',\r\n\t\tHf:'Гафний', Ta:'Тантал', W:'Вольфрам', Re:'Рений', Os:'Осмий', Ir:'Иридий',\r\n\t\tPt:'Платина', Au:'Золото', Hg:'Ртуть', Tl:'Таллий', Pb:'Свинец', Bi:'Висмут',\r\n\t\tPo:'Полоний', At:'Астат', Rn:'Радон', Fr:'Франций', Ra:'Радий', Ac:'Актиний',\r\n\t\tTh:'Торий', Pa:'Протактиний', U:'Уран', Np:'Нептуний', Pu:'Плутоний', Am:'Америций',\r\n\t\tCm:'Кюрий', Bk:'Берклий', Cf:'Калифорний', Es:'Эйнштейний', Fm:'Фермий',\r\n\t\tMd:'Менделеевий', No:'Нобелий', Lr:'Лоуренсий', Rf:'Резерфордий', Db:'Дубний',\r\n\t\tSg:'Сиборгий', Bh:'Борий', Hs:'Хассий', Mt:'Мейтнерий', Ds:'Дармштадтий',\r\n\t\tRg:'Рентгений', Cn:'Коперниций'\r\n\t},\r\n\ten: {\r\n\t\t'Invalid version': 'Formula requires CharChem version [need] instead of [cur]',\r\n\t\t$Native: 'English', $English: 'English',\r\n\t\t'Table legend': 'Chemical element groups',\r\n\t\tH:'Hydrogen', He:'Helium', Li:'Lithium', Be:'Beryllium', B:'Boron', C:'Carbon',\r\n\t\tN:'Nitrogen', O:'Oxygen', F:'Fluorine', Ne:'Neon', Na:'Sodium', Mg:'Magnesium',\r\n\t\tAl:'Aluminium', Si:'Silicon', P:'Phosphorus', S:'Sulfur', Cl:'Chlorine', Ar:'Argon',\r\n\t\tK:'Potassium', Ca:'Calcium', Sc:'Scandium', Ti:'Titanium', V:'Vanadium', Cr:'Chromium',\r\n\t\tMn:'Manganese', Fe:'Iron', Co:'Cobalt', Ni:'Nickel', Cu:'Copper', Zn:'Zinc',\r\n\t\tGa:'Gallium', Ge:'Germanium', As:'Arsenic', Se:'Selenium', Br:'Bromine', Kr:'Krypton',\r\n\t\tRb:'Rubidium', Sr:'Strontium', Y:'Yttrium', Zr:'Zirconium', Nb:'Niobium', Mo:'Molybdenum',\r\n\t\tTc:'Technetium', Ru:'Ruthenium', Rh:'Rhodium', Pd:'Palladium', Ag:'Silver', Cd:'Cadmium',\r\n\t\tIn:'Indium', Sn:'Tin', Sb:'Antimony', Te:'Tellurium', I:'Iodine', Xe:'Xenon',\r\n\t\tCs:'Caesium', Ba:'Barium', La:'Lanthanum', Ce:'Cerium', Pr:'Praseodymium', Nd:'Neodymium',\r\n\t\tPm:'Promethium', Sm:'Samarium', Eu:'Europium', Gd:'Gadolinium', Tb:'Terbium',\r\n\t\tDy:'Dysprosium', Ho:'Holmium', Er:'Erbium', Tm:'Thulium', Yb:'Ytterbium', Lu:'Lutetium',\r\n\t\tHf:'Hafnium', Ta:'Tantalum', W:'Tungsten', Re:'Rhenium', Os:'Osmium', Ir:'Iridium',\r\n\t\tPt:'Platinum', Au:'Gold', Hg:'Mercury', Tl:'Thallium', Pb:'Lead', Bi:'Bismuth',\r\n\t\tPo:'Polonium', At:'Astatine', Rn:'Radon', Fr:'Francium', Ra:'Radium', Ac:'Actinium',\r\n\t\tTh:'Thorium', Pa:'Protactinium', U:'Uranium', Np:'Neptunium', Pu:'Plutonium', Am:'Americium',\r\n\t\tCm:'Curium', Bk:'Berkelium', Cf:'Californium', Es:'Einsteinium', Fm:'Fermium',\r\n\t\tMd:'Mendelevium', No:'Nobelium', Lr:'Lawrencium', Rf:'Rutherfordium', Db:'Dubnium',\r\n\t\tSg:'Seaborgium', Bh:'Bohrium', Hs:'Hassium', Mt:'Meitnerium', Ds:'Darmstadtium',\r\n\t\tRg:'Roentgenium', Cn:'Copernicium'\r\n\t}\r\n}\r\n\r\n\r\nexport default Lang\r\n\n\n\n// WEBPACK FOOTER //\n// src/Lang.js","/**\r\n * Created by PeterWin on 27.04.2017.\r\n */\r\n'use strict'\r\n\r\nimport Lang from '../Lang'\r\n\r\n// extends Error\r\nfunction ChemError(msgId, params) {\r\n\r\n\t/**\r\n\t * Get localized message.\r\n\t * Language of message init by Lang.locale\r\n\t * @const\r\n\t * @returns {string}\r\n\t */\r\n\tthis.getMessage = () =>\r\n\t\tLang.tr(this.msgId, this.params)\r\n\r\n\r\n\tthis.msgId = msgId\r\n\tthis.params = params\r\n\tthis.message = this.getMessage()\r\n}\r\nChemError.prototype = new Error\r\n\r\nexport default ChemError\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemError.js","/**\r\n * Elements list\r\n * Each element is record {id, elem, n}\r\n * For abstract  elem is null\r\n * Created by PeterWin on 29.04.2017.\r\n */\r\n\"use strict\"\r\n\r\nimport ChemSys from '../ChemSys'\r\n\r\nexport class ElemRec {\r\n\r\n\t/**\r\n\t * @constructor\r\n\t * @param {string|ChemAtom|ElemRec|{id,elem,n}} src\r\n\t * @param {number} koeff\r\n\t */\r\n\tconstructor(src, koeff = 1) {\r\n\t\tlet rec = this\r\n\t\trec.n = koeff\r\n\r\n\t\tif (typeof src === 'string') {\t// Строковое описание элемента\r\n\t\t\trec.id = src\r\n\t\t\trec.elem = ChemSys.findElem(src)\r\n\t\t} else if (src.M) {\t// ChemAtom\r\n\t\t\trec.elem = src\r\n\t\t\trec.id = src.id\r\n\t\t} else {\t// Другой ElemRec\r\n\t\t\trec.elem = src.elem\r\n\t\t\trec.id = src.id\r\n\t\t\trec.n *= src.n\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * For abstract elems: {R}, for else: H, He\r\n\t * @returns {string}\r\n\t */\r\n\tget key() {\r\n\t\treturn this.elem ? this.id : '{'+this.id+'}'\r\n\t}\r\n}\r\n\r\n\r\n\r\nclass ElemList extends Array\r\n{\r\n\tconstructor() {\r\n\t\tsuper()\r\n\t\tlet list = this\r\n\t\tlist.charge = 0\r\n\r\n\t\t// it's look like a bug in Babel: prototype functions are invisible\r\n\r\n\t\t/**\r\n\t\t * Find element\r\n\t\t * @param {string|ChemAtom} elem\tExamples: 'He', 'Li', MenTbl.Be\r\n\t\t * @returns {number}\r\n\t\t */\r\n\t\tlist.findElem = elem => {\r\n\t\t\tif (typeof elem === 'string') {\r\n\t\t\t\telem = ChemSys.findElem(elem)\r\n\t\t\t}\r\n\t\t\tlet i = 0, n = list.length\r\n\t\t\tfor (; i < n; i++) {\r\n\t\t\t\tif (list[i].elem === elem)\r\n\t\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t\treturn -1\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Find custom element\r\n\t\t * @param {string} id\r\n\t\t * @returns {int}\r\n\t\t */\r\n\t\tlist.findCustom = function(id) {\r\n\t\t\tlet i=0, n=list.length, rec;\r\n\t\t\tfor (; i<n; i++) {\r\n\t\t\t\trec = list[i];\r\n\t\t\t\tif (!rec.elem && rec.id===id)\r\n\t\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Find element by key: 'H' or '{R}'\r\n\t\t * @param {string} key\r\n\t\t * @returns {int}\r\n\t\t */\r\n\t\tlist.findKey = function(key) {\r\n\t\t\tlet j=0, n=list.length, rec;\r\n\t\t\tfor (; j<n; j++) {\r\n\t\t\t\trec = list[j]\r\n\t\t\t\tif (rec.key === key)\r\n\t\t\t\t\treturn j\r\n\t\t\t}\r\n\t\t\treturn -1\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Find ElemRec\r\n\t\t * @param {ElemRec} rec\r\n\t\t * @returns {int}\r\n\t\t */\r\n\t\tlist.findRec = rec => {\r\n\t\t\tif (rec.elem) {\r\n\t\t\t\treturn list.findElem(rec.elem);\r\n\t\t\t} else {\r\n\t\t\t\treturn list.findCustom(rec.id);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Add element record\r\n\t\t * Attantion! Don't add one instance of record in different lists!\r\n\t\t * Use addElem to safe add operation\r\n\t\t * @param {ElemRec} rec\r\n\t\t */\r\n\t\tlist.addElemRec = rec => {\r\n\t\t\tlet k = list.findRec(rec)\r\n\t\t\tif (k<0) {\r\n\t\t\t\tlist.push(rec)\r\n\t\t\t} else {\r\n\t\t\t\tlist[k].n += rec.n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Add element\r\n\t\t * @param {string|ChemAtom|ElemRec} elem\r\n\t\t * @param {number=1} n\tkoefficient\r\n\t\t */\r\n\t\tlist.addElem = (elem, n) =>\r\n\t\t\tlist.addElemRec(new ElemRec(elem, n))\r\n\r\n\r\n\t\t/**\r\n\t\t * Add abstract element.\r\n\t\t * @param {string} text\tWithout { and }\r\n\t\t * @param {number=1} n\r\n\t\t */\r\n\t\tlist.addCustom = (text, n=1) =>\r\n\t\t\tlist.addElemRec(new ElemRec({id:text, elem:null, n}))\r\n\r\n\r\n\t\t/**\r\n\t\t * Add another elements list\r\n\t\t * @param {ElemList} srcList\tsource list will not change\r\n\t\t */\r\n\t\tlist.addList = srcList => {\r\n\t\t\tsrcList.forEach(rec => list.addElemRec(new ElemRec(rec)))\r\n\t\t\tlist.charge += srcList.charge;\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * add chemical radical\r\n\t\t * @param {ChemRadical} radical\r\n\t\t */\r\n\t\tlist.addRadical = radical => {\r\n\t\t\tlist.addList(radical.items)\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Scale all items by coefficient\r\n\t\t * @param {number} k\r\n\t\t */\r\n\t\tlist.scale = k => {\r\n\t\t\tif (k!==1) {\r\n\t\t\t\tlist.forEach(item => item.n *= k)\r\n\t\t\t\tlist.charge *= k\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlist.toString = () => {\r\n\t\t\tlet result = list.reduce((acc, item) => acc+item.key+(item.n===1 ? '':item.n), '')\r\n\t\t\tif (list.charge) {\r\n\t\t\t\tresult += '^'\r\n\t\t\t\tlet ach = Math.abs(list.charge)\r\n\t\t\t\tif (ach!==1) result += ach\r\n\t\t\t\tresult += (list.charge < 0) ? '-':'+'\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t}\r\n\r\n\t\t// sort by Hill system\r\n\t\tlist.sortByHill = () => {\r\n\t\t\tconst cmp = (a, b) => a<b ? -1 : (a>b ? 1: 0)\r\n\r\n\t\t\tlist.sort((a,b) => {\r\n\t\t\t\tlet aid = a.id, bid = b.id\r\n\t\t\t\tif (!a.elem && !b.elem)\r\n\t\t\t\t\treturn cmp(aid, bid)\r\n\t\t\t\tif (!a.elem)\r\n\t\t\t\t\treturn 1\r\n\t\t\t\tif (!b.elem)\r\n\t\t\t\t\treturn -1\r\n\t\t\t\tif (aid===bid)\r\n\t\t\t\t\treturn 0\r\n\t\t\t\tif (aid==='C')\r\n\t\t\t\t\treturn -1\r\n\t\t\t\tif (bid==='C')\r\n\t\t\t\t\treturn 1\r\n\t\t\t\tif (aid==='H')\r\n\t\t\t\t\treturn -1\r\n\t\t\t\tif (bid==='H')\r\n\t\t\t\t\treturn 1\r\n\t\t\t\treturn cmp(aid, bid)\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default ElemList\n\n\n// WEBPACK FOOTER //\n// src/core/ElemList.js","/**\r\n * 2D Point (or vector) object\r\n * Created by PeterWin on 26.04.2017.\r\n */\r\n'use strict'\r\n\r\nexport default class Point {\r\n\r\n\t/**\r\n\t * Constructor of 2D point\r\n\t * @param {number=} x\tX coordinate\r\n\t * @param {number=} y\tY coordinate\r\n\t */\r\n\tconstructor(x, y) {\r\n\t\tif (x === undefined) {\r\n\t\t\tthis.x = this.y = 0\r\n\t\t} else {\r\n\t\t\tthis.x = x\r\n\t\t\t// if y is undefined, then assumed Point(11) -> {x:11, y:11}\r\n\t\t\tthis.y = y === undefined ? x : y\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Comparison with zero, given errors of less than one thousandth\r\n\t * @param {number} value\r\n\t * @returns {boolean}\r\n\t */\r\n\tstatic is0(value) {\r\n\t\treturn Math.abs(value) < 0.001\r\n\t}\r\n\r\n\t/**\r\n\t * Reusing a point instance with new values\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t */\r\n\tinit(x, y) {\r\n\t\tthis.x = x\r\n\t\tthis.y = y\r\n\t}\r\n\r\n\t/**\r\n\t * Copying a point from another object\r\n\t * @param {Point} pt\r\n\t */\r\n\tfrom(pt) {\r\n\t\tthis.x = pt.x\r\n\t\tthis.y = pt.y\r\n\t}\r\n\r\n\t/**\r\n\t * Point cloning\r\n\t * @const\r\n\t * @returns {Point}\r\n\t */\r\n\tclone() {\r\n\t\treturn new Point(this.x, this.y)\r\n\t}\r\n\r\n\t/**\r\n\t * Comparison of two points\r\n\t * @const\r\n\t * @param {Point} pt\r\n\t * @returns {boolean}\r\n\t */\r\n\teq(pt) {\r\n\t\treturn Point.is0(this.x - pt.x) && Point.is0(this.y - pt.y)\r\n\t}\r\n\r\n\t//=================== addition\r\n\r\n\t/**\r\n\t * Point operator += (x, y)\r\n\t * add internal numbers\r\n\t * @param x\r\n\t * @param y\r\n\t * @returns {Point}\r\n\t */\r\n\taddin(x, y) {\r\n\t\tthis.x += x\r\n\t\tthis.y += y\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Point operator += (Point)\r\n\t * add internal (Point)\r\n\t * @param {Point} pt\r\n\t * @returns {Point}\r\n\t */\r\n\taddi(pt) {\r\n\t\tthis.x += pt.x\r\n\t\tthis.y += pt.y\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Point operator + (x, y)\r\n\t * add external numbers\r\n\t * @const\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t */\r\n\taddxn(x, y) {\r\n\t\treturn new Point(this.x + x, this.y + y)\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Point operator + (Point)\r\n\t * add external (Point)\r\n\t * @const\r\n\t * @param pt\r\n\t * @returns {Point}\r\n\t */\r\n\taddx(pt) {\r\n\t\treturn new Point(this.x + pt.x, this.y + pt.y)\r\n\t}\r\n\r\n\t// ================== subtraction\r\n\r\n\t/**\r\n\t * Point operator -= (x, y)\r\n\t * subtraction internal numbers\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t * @returns {Point}\r\n\t */\r\n\tsubin(x, y) {\r\n\t\tthis.x -= x\r\n\t\tthis.y -= y\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Point operator - (Point)\r\n\t * subtraction internal (Point)\r\n\t * @param {Point} pt\r\n\t * @returns {Point}\r\n\t */\r\n\tsubi(pt) {\r\n\t\tthis.x -= pt.x\r\n\t\tthis.y -= pt.y\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Point operator - (x, y)\r\n\t * @const\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t * @returns {Point}\r\n\t */\r\n\tsubxn(x, y) {\r\n\t\treturn new Point(this.x - x, this.y - y)\r\n\t}\r\n\r\n\t/**\r\n\t * Point operator - (Point)\r\n\t * sub external (Point)\r\n\t * @const\r\n\t * @param {Point} pt\r\n\t * @returns {Point}\r\n\t */\r\n\tsubx(pt) {\r\n\t\treturn new Point(this.x - pt.x, this.y - pt.y)\r\n\t}\r\n\r\n\t/**\r\n\t * min internal numbers\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t * @returns {Point}\r\n\t */\r\n\tminin(x, y) {\r\n\t\tthis.x = Math.min(this.x, x)\r\n\t\tthis.y = Math.min(this.y, y)\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * min internal (Point)\r\n\t * @param {Point} pt\r\n\t * @returns {Point}\r\n\t */\r\n\tmini(pt) {\r\n\t\treturn this.minin(pt.x, pt.y)\r\n\t}\r\n\r\n\t/**\r\n\t * max internal numbers\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t * @return {Point}\r\n\t */\r\n\tmaxin(x, y) {\r\n\t\tthis.x = Math.max(this.x, x)\r\n\t\tthis.y = Math.max(this.y, y)\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * max internal (Point)\r\n\t * @param {Point} pt\r\n\t * @return {Point}\r\n\t */\r\n\tmaxi(pt) {\r\n\t\treturn this.maxin(pt.x, pt.y)\r\n\t}\r\n\r\n\t/**\r\n\t * negative internal: pt = -pt\r\n\t * @returns {Point}\r\n\t */\r\n\tnegi() {\r\n\t\tthis.x = -this.x\r\n\t\tthis.y = -this.y\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * negative external\r\n\t * Point operator - () const\r\n\t * @const\r\n\t * @returns {Point}\r\n\t */\r\n\tnegx() {\r\n\t\treturn new Point(-this.x, -this.y)\r\n\t}\r\n\r\n\t/**\r\n\t * internal multiply by koefficient\r\n\t * Point operator *= (number)\r\n\t * @param {number} k\r\n\t * @returns {Point}\r\n\t */\r\n\tmuli(k) {\r\n\t\tthis.x *= k\r\n\t\tthis.y *= k\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * external multiply by koefficient\r\n\t * Point operator * (number) const\r\n\t * @const\r\n\t * @param k\r\n\t * @returns {Point}\r\n\t */\r\n\tmulx(k) {\r\n\t\treturn new Point(this.x * k, this.y * k)\r\n\t}\r\n\r\n\t/**\r\n\t * square of length\r\n\t * @const\r\n\t * @returns {number}\r\n\t */\r\n\tlengthSqr() {\r\n\t\treturn this.x * this.x + this.y * this.y\r\n\t}\r\n\r\n\t/**\r\n\t * Length\r\n\t * @const\r\n\t * @returns {number}\r\n\t */\r\n\tlength() {\r\n\t\treturn Math.sqrt(this.lengthSqr())\r\n\t}\r\n\r\n\t/**\r\n\t * Square of distance to point, defined by numbers\r\n\t * @const\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t * @returns {number}\r\n\t */\r\n\tdistSqrn(x, y) {\r\n\t\tlet dx = this.x - x, dy = this.y - y\r\n\t\treturn dx * dx + dy * dy\r\n\t}\r\n\r\n\t/**\r\n\t * Square of distance to point\r\n\t * @const\r\n\t * @param {Point} pt\r\n\t * @returns {number}\r\n\t */\r\n\tdistSqr(pt) {\r\n\t\treturn this.distSqrn(pt.x, pt.y)\r\n\t}\r\n\r\n\t/**\r\n\t * Distance to point\r\n\t * @const\r\n\t * @param pt\r\n\t * @returns {number}\r\n\t */\r\n\tdist(pt) {\r\n\t\treturn Math.sqrt(this.distSqr(pt))\r\n\t}\r\n\r\n\t/**\r\n\t * Make unit vector from angle (in radians)\r\n\t * @param {number} radAngle\t\tangle in radians, for ex: Math.PI/2\r\n\t * @returns {Point}\r\n\t */\r\n\tfromRad(radAngle) {\r\n\t\tthis.x = Math.cos(radAngle)\r\n\t\tthis.y = Math.sin(radAngle)\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Make unit vector from angle (in degrees)\r\n\t * @param {number} degAngle\r\n\t * @returns {Point}\r\n\t */\r\n\tfromDeg(degAngle) {\r\n\t\treturn this.fromRad(Math.PI * degAngle / 180)\r\n\t}\r\n\r\n\t/**\r\n\t * Transpose internal\r\n\t * @returns {Point}\r\n\t */\r\n\ttransponi() {\r\n\t\tlet tmp = this.x\r\n\t\tthis.x = this.y\r\n\t\tthis.y = tmp\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Transpose external\r\n\t * @const\r\n\t * @returns {Point}\r\n\t */\r\n\ttransponx() {\r\n\t\treturn new Point(this.y, this.x)\r\n\t}\r\n\r\n\t/**\r\n\t * Rounding and casting to string\r\n\t * @param {number} value\r\n\t * @returns {string}\r\n\t */\r\n\tstatic toa(value) {\r\n\t\treturn (Math.round(value * 1000) / 1000).toString()\r\n\t}\r\n\r\n\t/**\r\n\t * Make string from point\r\n\t * @const\r\n\t * @returns {string}\r\n\t */\r\n\ttoString() {\r\n\t\treturn `{${Point.toa(this.x)}, ${Point.toa(this.y)}}`\r\n\t}\r\n\r\n\t/**\r\n\t * Calculate the angle from vector\r\n\t *  *----> X\r\n\t *  | *\r\n\t *  |   *\r\n\t *  v     *\r\n\t *  Y\r\n\t *  (10,10) -> Pi/4 (45º); (10, -10) -> -Pi/4 (-45º)\r\n\t * @const\r\n\t * @returns {number} angle in radians, in range from -Pi to Pi\r\n\t */\r\n\tpolarAngle() {\r\n\t\tif (this.x === 0) {\r\n\t\t\tif (this.y === 0) {\r\n\t\t\t\treturn 0\r\n\t\t\t}\r\n\t\t\treturn this.y > 0 ? Math.PI / 2 : -Math.PI / 2\r\n\t\t}\r\n\t\treturn Math.atan2(this.y, this.x)\r\n\t}\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/math/Point.js","/**\r\n * Created by PeterWin on 06.05.2017.\r\n */\r\n\r\n// visitor Для определения невозможности вывода выражения (или его части) в виде текста\r\n// example: if (expr.walk(new IsNonText())) alert('This is not textual expression');\r\nexport default class IsNonText {\r\n\tconstructor() {\r\n\t\tthis.ok = false\r\n\t}\r\n\tbond(obj) {\r\n\t\t// Большинство связей не является текстовыми\r\n\t\treturn this.ok = obj.bText ^ 1\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/visitors/IsNonText.js","/**\r\n * The module for compiling the source code of an expression.\r\n * The result is always ChemExpr, which can contain a description of the error\r\n * Created by PeterWin on 28.04.2017.\r\n */\r\n'use strict'\r\n\r\nimport ChainSys from './chainSys'\r\nimport ChemAgent from '../core/ChemAgent'\r\nimport ChemBond from '../core/ChemBond'\r\nimport { ChemBrBegin, ChemBrEnd } from '../core/ChemBr'\r\nimport ChemComment from '../core/ChemComment'\r\nimport ChemCharge from '../core/ChemCharge'\r\nimport ChemCustom from '../core/ChemCustom'\r\nimport ChemError from '../core/ChemError'\r\nimport ChemExpr from '../core/ChemExpr'\r\nimport ChemMul, { ChemMulEnd } from '../core/ChemMul'\r\nimport ChemNode from '../core/ChemNode'\r\nimport ChemNodeItem from '../core/ChemNodeItem'\r\nimport ChemRadical from '../core/ChemRadical'\r\nimport ChemSys from '../ChemSys'\r\nimport ChemOp from '../core/ChemOp'\r\nimport Lang from '../Lang'\r\nimport Point from '../math/Point'\r\nimport { preProcess } from '../compiler/preprocess'\r\nimport { MenTbl } from '../core'\r\nimport IsNonText from '../visitors/IsNonText'\r\nimport { dashes, dots } from './utils'\r\n\r\nfunction _notImpl(fnName) {\r\n\tthrow new ChemError('Function is not implemented: ' + fnName)\r\n}\r\n\r\n// Replacement of special characters in the comments\r\nconst SpecChars = [\r\n\t[/\\|\\^|ArrowUp/g, '↑'],\r\n\t[/(\\|v)|(ArrowDown)/g, '↓'],\r\n\t[/\\^o/g, '°']\r\n]\r\n\r\nconst SpecCharsB = {\r\n\talpha: 'α', Alpha: 'Α',\r\n\tbeta: 'β', Beta: 'Β',\r\n\tgamma: 'γ', Gamma: 'Γ',\r\n\tdelta: 'δ', Delta: 'Δ',\r\n\tepsilon: 'ε', Epsilon: 'Ε',\r\n\tzeta: 'ζ', Zeta: 'Ζ',\r\n\teta: 'η', Eta: 'Η',\r\n\ttheta: 'θ', Theta: 'Θ',\r\n\tiota: 'ι', Iota: 'Ι',\r\n\tkappa: 'κ', Kappa: 'Κ',\r\n\tlambda: 'λ', Lambda: 'Λ',\r\n\tmu: 'μ', Mu: 'Μ',\r\n\tnu: 'ν', Nu: 'Ν',\r\n\txi: 'ξ', Xi: 'Ξ',\r\n\tomicron: 'ο', Omicron: 'Ο',\r\n\tpi: 'π', Pi: 'Π',\r\n\trho: 'ρ', Rho: 'Ρ',\r\n\tsigma: 'σ', Sigma: 'Σ',\r\n\ttau: 'τ', Tau: 'Τ',\r\n\tupsilon: 'υ', Upsilon: 'Υ',\r\n\tphi: 'φ', Phi: 'Φ',\r\n\tchi: 'χ', Chi: 'Χ',\r\n\tpsi: 'ψ', Psi: 'Ψ',\r\n\tomega: 'ω', Omega: 'Ω'\r\n}\r\n\r\nconst Ops = [\r\n\t{ op: '+' },\r\n\t{ op: '-->', eq:1, dst:'—→' },\r\n\t{ op: '->', eq:1, dst:'→' },\r\n\t{ op: '®', eq:1, dst:'→' },\r\n\t{ op: '→', eq:1 },\r\n\t{ op: '=', eq:1 },\r\n\t{ op: '↔', eq:1 },\r\n\t{ op: '<->', eq:1, dst:'↔' },\r\n\t{ op: '<=>', eq:1, dst:'\\u21CC' },\r\n\t{ op: '<==>', eq:1, dst:'\\u21CC' },\r\n\t{ op: '*', dst:'∙' },\r\n\t{ op: '!=', dst:'≠' }\r\n]\r\n\r\n// Bonds description synonims\r\nconst BondsSyn = {\r\n\t'≡': '%',\r\n\t'–': '-'\r\n}\r\n\r\n// 0=(Multiplicity), 1=(Angle in degrees), 2=(sign of slope), 3=(soft bond flag), 4=(text)\r\nconst BondDefs = {\r\n\t'-': [1, 0, 0, 1],\r\n\t'=': [2, 0, 0, 1],\r\n\t'%': [3, 0, 0, 1, '≡'],\r\n\t'--': [1, 0, 0, 0, '-'],\r\n\t'==': [2, 0, 0, 0, '='],\r\n\t'%%': [3, 0, 0, 0, '≡'],\r\n\t'|':  [1, 90, 0],\r\n\t'||': [2, 90, 0],\r\n\t'|||': [3, 90, 0],\r\n\t'/': [1, 0, -1],\r\n\t'///': [3, 0, -1],\r\n\t'//': [2, 0, -1],\r\n\t'\\\\': [1, 0, 1],\r\n\t'\\\\\\\\': [2, 0, 1],\r\n\t'\\\\\\\\\\\\': [3, 0, 1]\r\n}\r\n\r\nconst NumConst = {\r\n\t'$32': Math.sqrt(3) / 2,\r\n\t'$3': Math.sqrt(3),\r\n\t'$3x2': Math.sqrt(3) * 2,\r\n\t'$2': Math.sqrt(2),\r\n\t'$22': Math.sqrt(2) / 2,\r\n\t'$2x2': Math.sqrt(2) * 2,\r\n\t'½':0.5, '¼':1 / 4, '¾': 3 / 4, '⅓':1 / 3, '⅔':2 / 3\r\n}\r\n\r\nlet BondDefMap = {}\t// Map 'first char'=>1 for parseNode optimization\r\n\r\n\r\n//==========================================\r\n//\t\tcompiler first initialization\r\n!function () {\r\n\t// 180 -- π, grad -- rad,  rad=grad*π/180 = grad*k,  k=π/180\r\n\tlet i, k = Math.PI / 180\r\n\t// convert degreese to radians\r\n\tfor (i in BondDefs)\r\n\t\tBondDefs[i][1] *= k\r\n\r\n\t// Подключить синонимы связей\r\n\tfor (i in BondsSyn)\r\n\t\tBondDefs[i] = BondDefs[BondsSyn[i]]\r\n\r\n\t// Заполнить BondDefMap\r\n\tfor (i in BondDefs)\r\n\t\tBondDefMap[i.charAt(0)] = 1\r\n}()\r\n\r\nconst isSpace = ch => ch === ' ' || ch === '\\t' || ch === '\\n'\r\nconst isDigit = ch => ch >= '0' && ch <= '9'\r\nconst isSmallAlpha = ch => ch >= 'a' && ch <= 'z'\r\n\r\n/**\r\n * Don't use this function directly. True way: ChemSys.compile\r\n * @param {string} text\r\n * @returns {ChemExpr}\r\n */\r\nexport function chemCompiler(text) {\r\n\r\n\tlet\r\n\t\tresult = new ChemExpr(),\r\n\t\ttextLen,\r\n\t\tpos = 0,\t// current position in text\r\n\t\tc,\t// current character\r\n\t\tcurState = 'begin',\r\n\r\n\t\tcommentPre = 0,\t// The line of the preliminary comment\r\n\t\tcommentPrePos = 0,\r\n\t\tcurEntity,\t// Current entity (item of chemical expression)\r\n\t\tcurPart = 0,\t// Index of expression part. Parts are separated by operations with a eq, for ex. = or ->\r\n\t\tkoeffPre,\t\t// Prefix coefficient\r\n\t\tkoeffPrePos,\t// position of prefix coefficient\r\n\t\titemPos0,\t// Position of node begin. Позиция начала элемента узла\r\n\r\n\t\tchainSys,\t// Chain system for agent\r\n\t\tcurNode,\t// current node\r\n\t\tchargeOwner,\t// Target object for ^ operation. Объект, к которому применится конструкция ^\r\n\t\tcurNodeEnd,\t// Position of current node end. Позиция конца текущего узла\r\n\t\tcurBond,\t// current bond\r\n\t\tprevBond,\t// previous bond (for auto-correction)\r\n\t\tbranchStack,\t// branch stack\r\n\t\tbracketEnds = [],\r\n\t\tmiddlePoints = [],\t// Middle points list for curved bonds. Список промежуточных точек для изогнутых связей\r\n\t\tnodesBranch = [],\t// Список линейно связанных узлов (свой для каждой ветки). Заполняется через push\r\n\t\tpostNodeInits = [],\t//  void(ChemNode) functions для пост-инициализации узлов\r\n\r\n\t\tnodesMap,\t// named nodes for  #Name access\r\n\t\tbNegChar = 0,\t// Признак изменения поведения следующей конструкции (обратный апостроф)\r\n\t\tcurWidth = 0,\t// Текущая толщина, нстраиваемая W+,W2,W-,D+,D-,D2\r\n\r\n\t\tuserSlope = 0,\t// Наклон кратких описаний связей, заданный функцией $slope\r\n\t\tdefaultSlope = Math.PI / 6,\t// 30° - стандартный наклон кратких описаний связей\r\n\t\tdegToRad = Math.PI / 180,\r\n\r\n\t\tst_agentMid = 'agentMid',\r\n\t\t_findElem = ChemSys.findElem\r\n\r\n\r\n\tconst nextChar = () => text[pos + 1]\r\n\r\n\tconst error = (msgId, par) => {\r\n\t\tif ('pos' in par) {\r\n\t\t\tpar.pos++\r\n\t\t}\r\n\t\tthrow new ChemError(msgId, par)\r\n\t}\r\n\r\n\tconst checkMiddlePoints = () => {\r\n\t\tif (middlePoints.length) {\r\n\t\t\terror('Invalid middle point', middlePoints[0])\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Add command to current agent\r\n\t * @param {ChemNode|ChemBond|ChemMul|ChemMulEnd} cmd\r\n\t */\r\n\tconst addCmd = cmd => curEntity.cmds.push(cmd)\r\n\r\n\t// Check the presence of a multiplier (construction: *5H2O)\r\n\tfunction checkMul() {\r\n\t\tlet mulRec = branchStack[0]\r\n\t\tif (mulRec && mulRec.m) {\r\n\t\t\tbranchStack.shift()\r\n\t\t\tlet begin = mulRec.m,\r\n\t\t\t\tend = new ChemMulEnd(begin)\r\n\t\t\tbegin.end = end\r\n\t\t\taddCmd(end)\r\n\t\t}\r\n\t}\r\n\r\n\t//==================== States control\r\n\t/**\r\n\t * set state\r\n\t * @param {string} st\r\n\t * @param {number=0} res\r\n\t * @returns {number}\r\n\t */\r\n\tconst setState = (st, res = 0) => {\r\n\t\tcurState = st\r\n\t\treturn res\r\n\t}\r\n\r\n\tconst _substr = pos0 => text.slice(pos0, pos)\r\n\r\n\tconst skipSpace = () => {\r\n\t\twhile (pos < textLen && isSpace(c = text[pos])) pos++\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves a comment\r\n\t * Initially, pos must be set to the first character inside the quotes.\r\n\t * At the end it is set to the final quotation mark\r\n\t * @returns {string}\r\n\t */\r\n\tfunction scanComment() {\r\n\t\tlet p0 = pos\r\n\t\twhile (pos < textLen && text[pos] !== '\"') pos++\r\n\t\tif (pos === textLen)\r\n\t\t\terror('Comment is not closed', { pos:p0 - 1 })\r\n\t\treturn _substr(p0)\r\n\t}\r\n\r\n\t// Извлечь список аргументов и их позиций, начиная с текущей позиции\r\n\tfunction scanArgs(args, argPos) {\r\n\t\tlet p0 = pos, prev = pos, ch, level = 0\r\n\t\tfunction addArg() {\r\n\t\t\targPos.push(prev)\r\n\t\t\targs.push(_substr(prev))\r\n\t\t\tprev = pos + 1\r\n\t\t}\r\n\t\tfor (; pos < textLen; pos++) {\r\n\t\t\tch = text[pos]\r\n\t\t\tif (ch === '(') {\r\n\t\t\t\tlevel++\r\n\t\t\t} else if (ch === ')') {\r\n\t\t\t\tif (level-- === 0) break\r\n\t\t\t} else if (ch === ',' && level === 0) {\r\n\t\t\t\taddArg()\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (pos >= textLen)\r\n\t\t\terror('It is necessary to close the bracket', { pos:p0 - 1 })\r\n\t\taddArg()\r\n\t\t++pos\r\n\t}\r\n\r\n\r\n\t// Попытка извлечь коэффициент\r\n\t// Если коэффициент распознан, возвращается число или строка(для абстрактного коэфф), pos указыв на следующий символ\r\n\t// В случае неудачи возвращает null\r\n\tfunction scanKoeff() {\r\n\t\tlet pos0 = pos,\r\n\t\t\tch = text[pos],\r\n\t\t\tres = null, s = '', r\r\n\t\tif (isDigit(ch)) {\r\n\t\t\t// Число...\r\n\t\t\twhile (pos < textLen) {\r\n\t\t\t\ts += text[pos]\r\n\t\t\t\tr = +s\t\t// Недостаточно проверки isNaN, т.к. \"10 \" тоже успешно превращается в 10. Поэтому используем регэксп\r\n\t\t\t\tif (isNaN(r) || !/^[\\d\\.]+$/.test(s)) break\r\n\t\t\t\tres = r\r\n\t\t\t\tpos++\r\n\t\t\t}\r\n\t\t} else if (ch === \"'\") {\r\n\t\t\t// Абстрактный коэфф.\r\n\t\t\tpos++\r\n\t\t\twhile (pos < textLen && text[pos] !== \"'\") pos++\r\n\t\t\tif (pos === textLen)\r\n\t\t\t\terror('Abstract koefficient is not closed', { pos:pos0 })\r\n\t\t\tres = _substr(pos0 + 1)\r\n\t\t\tpos++\r\n\t\t}\r\n\t\tif (res !== null) {\t// Предварительный комментарий не может следовать до коэффициента\r\n\t\t\tcommentPre = 0\r\n\t\t}\r\n\t\treturn res\r\n\t}\r\n\r\n\t// Извлечение заряда из текущей позиции.\r\n\t// Возвращает объект ChemCharge или 0\r\n\tfunction scanCharge() {\r\n\t\tlet chargeText = '', chargePrev = 0, charge\r\n\t\twhile (pos < textLen) {\r\n\t\t\tchargeText += text[pos]\r\n\t\t\tcharge = ChemCharge.create(chargeText)\r\n\t\t\tif (!charge) break\r\n\t\t\tpos++\r\n\t\t\tchargePrev = charge\r\n\t\t}\r\n\t\treturn chargePrev\r\n\t}\r\n\r\n\t// Попытка извлечь из текущей позиции степень окисления\r\n\tfunction scanOxidation() {\r\n\t\tlet i = pos, charge = 0\r\n\t\tif (text[i] === '(') {\r\n\t\t\twhile (i < textLen && text[i] !== ')') i++\r\n\t\t\tif (text[i] !== ')')\r\n\t\t\t\terror('It is necessary to close the bracket', { pos:pos })\r\n\t\t\tcharge = ChemCharge.create(text.slice(pos + 1, i))\r\n\t\t\tif (charge) {\r\n\t\t\t\tpos = i + 1\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn charge\r\n\t}\r\n\r\n\t////////////////////////////////////////////////////\r\n\t//\t\tComments\r\n\r\n\t/**\r\n\t *\r\n\t * @param {string} text\r\n\t * @returns {string}\r\n\t */\r\n\tfunction cvtComm(text) {\r\n\t\tlet i, p, res = text, kb, ke, s, a\r\n\t\tfor (p of SpecChars) {\r\n\t\t\tres = res.replace(p[0], p[1])\r\n\t\t}\r\n\t\t// Замена греческих букв в квадр. скобках\r\n\t\ti = 0\r\n\t\twhile (i < res.length) {\r\n\t\t\tkb = res.indexOf('[', i)\r\n\t\t\tif (kb < 0) break\r\n\t\t\tke = res.indexOf(']', kb)\r\n\t\t\tif (ke < 0) break\r\n\t\t\ts = res.slice(kb + 1, ke)\r\n\t\t\ta = SpecCharsB[s]\r\n\t\t\tif (a) {\r\n\t\t\t\t// греческая буква найдена. Выполняем замену\r\n\t\t\t\tres = res.substr(0, kb) + a + res.substr(ke + 1)\r\n\t\t\t} else {\r\n\t\t\t\t// греческая буква не найдена. Оставляем скобки в тексте\r\n\t\t\t\ti = kb + 1\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn translate(res)\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {string} res\r\n\t * @returns {string}\r\n\t */\r\n\tfunction translate(res) {\r\n\t\t// Поиск переводимых фраз\r\n\t\tlet t, s, k, i = res.indexOf('`')\r\n\t\twhile (i >= 0) {\r\n\t\t\tk = res.indexOf('`', i + 1)\r\n\t\t\tif (k < 0) break\r\n\t\t\ts = res.slice(i + 1, k)\r\n\t\t\tt = Lang.tr(s)\r\n\t\t\tif (t === s) {\r\n\t\t\t\t// перевод не получился\r\n\t\t\t\tres = res.slice(0, i) + res.slice(i + 1)\r\n\t\t\t} else {\r\n\t\t\t\t// заменить перевод\r\n\t\t\t\tres = res.slice(0, i) + t + res.slice(k + 1)\r\n\t\t\t}\r\n\t\t\ti = res.indexOf('`')\r\n\t\t}\r\n\t\tres = res.replace('`', '')\r\n\t\treturn res\r\n\t}\r\n\r\n\tconst makeComment = comm0 =>\r\n\t\tnew ChemComment(cvtComm(comm0))\r\n\r\n\tlet constMap = {}\r\n\tfunction toNum(x, xpos) {\r\n\t\tif (!x) return 0\r\n\t\tlet k = 1\r\n\t\tif (x[0] === '-') {\r\n\t\t\tk = -1; x = x.slice(1)\r\n\t\t}\r\n\t\tif (x[0] === '%') {\r\n\t\t\t// Использование или определение константы\r\n\t\t\tlet val, j = x.indexOf(':'), name\r\n\t\t\tif (j >= 0) {\r\n\t\t\t\t// Определение\r\n\t\t\t\tname = x.slice(1, j)\r\n\t\t\t\tval = x.slice(j + 1)\r\n\t\t\t\tconstMap[name] = val\r\n\t\t\t} else {\r\n\t\t\t\tname = x.slice(1)\r\n\t\t\t\tval = constMap[name]\r\n\t\t\t\tif (!val) error('Undefined variable [name]', { name:name, pos:xpos + 1 })\r\n\t\t\t}\r\n\t\t\tx = val\r\n\t\t}\r\n\t\tif (x in NumConst)\r\n\t\t\treturn k * NumConst[x]\r\n\t\treturn +x * k\r\n\t}\r\n\r\n\t// Система функций, обозначаемых через $\r\n\tlet specMass = 0, bAtomNum = 0, curColor = null, curItemColor = null, curItemColor1 = 0,\r\n\t\tcurAtomColor = null, curAtomColor1 = 0, stdLen = 1,\r\n\t\tnextDots = 0, // результат dots для следующего узла\r\n\t\tnextDashes = 0,\r\n\t\tdblAlignMode = 0, // режим выравнивания двойных связей\r\n\t\tfuncs = {\r\n\t\t\tatomColor: function (args) {\r\n\t\t\t\tcurAtomColor = args[0]\r\n\t\t\t},\r\n\t\t\tatomColor1: function (args) {\r\n\t\t\t\tcurAtomColor1 = args[0]\r\n\t\t\t},\r\n\t\t\tcolor: function (args) {\r\n\t\t\t\tcurColor = args[0]\r\n\t\t\t},\r\n\t\t\tdashes: function (args, argsPos) {\r\n\t\t\t\tnextDashes = dashes(args, argsPos, toNum)\r\n\t\t\t},\r\n\t\t\t// режим выравнивания двойных связей\r\n\t\t\tdblAlign: function (args) {\r\n\t\t\t\tdblAlignMode = args[0]\r\n\t\t\t},\r\n\t\t\t// Точки\r\n\t\t\tdots: function (args, argsPos) {\r\n\t\t\t\tnextDots = dots(args, argsPos, toNum)\r\n\t\t\t}, // dots\r\n\t\t\titemColor: function (args) {\r\n\t\t\t\tcurItemColor = args[0]\r\n\t\t\t},\r\n\t\t\titemColor1: function (args) {\r\n\t\t\t\tcurItemColor1 = args[0]\r\n\t\t\t},\r\n\t\t\t// Коэффициент длины связи по умолчанию (для формулы)\r\n\t\t\tL: function (arg, argPos) {\r\n\t\t\t\tstdLen = toNum(arg[0], argPos[0]) || 1\r\n\t\t\t},\r\n\t\t\t// Масса следующего элемента. Применимо не только к атомам, но кастомным элементам и даже группам\r\n\t\t\tM: function (args) {\r\n\t\t\t\tspecMass = +args[0]\r\n\t\t\t},\r\n\t\t\t// Масса следующего элемента плюс атомный номер   238 #  #\r\n\t\t\t// Например $nM(238)U                                 #  #\r\n\t\t\t//                                                 92  ##\r\n\t\t\tnM: function (args) {\r\n\t\t\t\tfuncs.M(args)\r\n\t\t\t\tbAtomNum = 1\r\n\t\t\t},\r\n\t\t\tslope: function (args) {\r\n\t\t\t\t// degree - radian | 180 - pi => radian = degree*pi/180\r\n\t\t\t\tuserSlope = args[0] * degToRad\r\n\t\t\t},\r\n\t\t\tver: function (args) {\r\n\t\t\t\tlet formulaVer = args[0].split('.'), sysVer = ChemSys.ver()\r\n\t\t\t\tif (formulaVer.length > 1) {\r\n\t\t\t\t\t// formulaVer[0] is string value and sysVer[0] is number => don't use strict  formulaVer[0] === sysVer[0]\r\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\r\n\t\t\t\t\tif (formulaVer[0] > sysVer[0] || (formulaVer[0] == sysVer[0] && formulaVer[1] > sysVer[1]))\r\n\t\t\t\t\t\terror('Invalid version', { cur:ChemSys.verStr(), need:formulaVer.join('.') })\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t//-----------------------------------------------\r\n\t//\tСущности хим выражения\r\n\tfunction createEntity(entity) {\r\n\t\tresult.ents.push(curEntity = entity)\r\n\t}\r\n\r\n\t//-----------------------------------------------\r\n\t//\tОперации в хим.выражении\r\n\r\n\tfunction checkOp() {\r\n\t\tlet c1, opDef, pos1, comm, j = Ops.length - 1\r\n\t\twhile (j >= 0 && text.indexOf(Ops[j].op, pos) !== pos) j--\r\n\t\tif (j < 0) return null\r\n\t\t// После операции нужен пробельный символ\r\n\t\topDef = Ops[j]\r\n\t\tpos1 = pos + opDef.op.length\r\n\t\tc1 = text.charAt(pos1)\r\n\t\tif (!isSpace(c1) && c1 !== '\"') return null\r\n\r\n\t\tcreateEntity(new ChemOp(opDef.op, opDef.dst || opDef.op, opDef.eq))\r\n\t\tcurEntity.setPos(pos, pos1)\r\n\t\tif (commentPre) {\r\n\t\t\tcomm = curEntity.commentPre = makeComment(commentPre)\r\n\t\t\tcurEntity.pA = comm.pA = commentPrePos - 1\r\n\t\t\tcomm.pB = pos\r\n\t\t\tcommentPre = 0\r\n\t\t}\r\n\t\tif (opDef.eq) curPart++ // переходим к следующей части уравнения\r\n\t\tpos = pos1\r\n\t\tif (text[pos] === '\"') {\r\n\t\t\t// Начать читать комментарий\r\n\t\t\tpos++\r\n\t\t\tcomm = curEntity.commentPost = makeComment( scanComment() )\r\n\t\t\tcomm.pA = pos1\r\n\t\t\tcurEntity.pB = comm.pB = ++pos\r\n\t\t}\r\n\t\t// начать считывание следующей сущности\r\n\t\treturn setState('begin')\r\n\t}\r\n\r\n\t//-----------------------------------------\r\n\t//\t\tАгент\r\n\t// Подготовка данных для распознавания агента\r\n\tfunction openAgent() {\r\n\t\tchainSys = new ChainSys()\r\n\t\tchargeOwner = curNode = 0\r\n\t\tcurBond = prevBond = 0\r\n\t\tbranchStack = []\r\n\t\tnodesBranch = []\r\n\t\tcurEntity.part = curPart\r\n\t\tnextDots = nextDashes = 0\r\n\t\tnodesMap = {} // именованные узлы для доступа через #Name\r\n\t\tlet p0 = pos\r\n\t\tcurWidth = 0\r\n\r\n\t\t// Присоединить ранее полученные коэффициент или коммент\r\n\t\tif (koeffPre) {\r\n\t\t\tcurEntity.n = koeffPre\r\n\t\t\tp0 = koeffPrePos\r\n\t\t} else if (typeof commentPre === 'string') {\r\n\t\t\t//_notImpl('openAgent.coeffPre')\r\n\t\t\tp0 = commentPrePos\r\n\t\t\taddNodeItem(makeComment(commentPre))\r\n\t\t}\r\n\t\tcurEntity.pA = p0\r\n\t}\r\n\r\n\t// Обработка незакрытой конструкции\r\n\tfunction branchError(obj) {\r\n\t\tif (obj.o) {\r\n\t\t\t// Незакрытая скобка\r\n\t\t\terror('It is necessary to close the bracket', { pos:obj.pos })\r\n\t\t} else {\r\n\t\t\t// Незакрытая ветка\r\n\t\t\terror('It is necessary to close the branch', { pos:obj.pos })\r\n\t\t}\r\n\t}\r\n\r\n\tfunction closeAgent() {\r\n\r\n\t\tlet branchCmd = null\r\n\t\t// Если в стеке есть мультипликатор, вытеснить его...\r\n\t\twhile (branchStack.length && branchStack[0].m)\r\n\t\t\tbranchCmd = branchStack.shift()\r\n\t\t// Если в стеке что-то есть, значит не закрыта открытая ранее конструкция\r\n\t\tif (branchStack.length) {\r\n\t\t\tbranchError(branchStack[0])\r\n\t\t}\r\n\r\n\t\tcloseNode()\r\n\t\tcloseBond()\r\n\t\tcheckMiddlePoints()\r\n\t\t//checkMul()\tTODO: Если вызывать здесь, то не заполняется команда ChemMulEnd\r\n\t\tif (branchCmd) {\r\n\t\t\taddCmd(new ChemMulEnd(branchCmd.m))\r\n\t\t}\r\n\t\tcurEntity.pB = pos\r\n\r\n\t\tlet i, bond, bonds = curEntity.bonds,\r\n\t\t\tcmds = curEntity.cmds, cmdIndex = 0,\r\n\t\t\tj, node, nodes, n, item,\r\n\t\t\tlmap = {}, key\r\n\r\n\t\t// Сращивание дублирующих связей\r\n\t\ti = 0\r\n\t\twhile (i < bonds.length) {\r\n\t\t\tbond = bonds[i++]\r\n\t\t\tnodes = bond.nodes\r\n\t\t\tif (nodes.length === 2 && !bond.midPt) {\t// Только для связей между двумя узлами И без промежуточных точек\r\n\t\t\t\tj = nodes[0].index\r\n\t\t\t\tn = nodes[1].index\r\n\t\t\t\tkey = Math.min(j, n) + ':' + Math.max(j, n) // ключ образуется индексами узлов от меньшего к большему\r\n\t\t\t\titem = lmap[key]\r\n\t\t\t\tif (item) { // Это не сравнение! а присваивание и отновременная проверка\r\n\t\t\t\t\t// Зафиксировано наложение\r\n\t\t\t\t\t// Добавляется количество связей, все остальные настройки игнорируются\r\n\t\t\t\t\titem.N += bond.N\r\n\t\t\t\t\tbonds.splice(--i, 1)\t// связь удаляется из списка\r\n\t\t\t\t\t// Удалить связь из списка команд агента\r\n\t\t\t\t\t// Используется тот факт, что команды идут в том же порядке, что и связи\r\n\t\t\t\t\t// Поэтому не нужно искать сначала списка\r\n\t\t\t\t\twhile (cmds[cmdIndex] !== bond) cmdIndex++\r\n\t\t\t\t\tcmds.splice(cmdIndex, 1)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlmap[key] = bond\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Необходимо заполнить список связей для каждого узла\r\n\t\tfor (i in bonds) { // цикл по связям\r\n\t\t\tbond = bonds[i]\r\n\t\t\tnodes = bond.nodes\r\n\t\t\tfor (j in nodes) { // цикл по узлам связи\r\n\t\t\t\tnode = nodes[j]\r\n\t\t\t\tnode.bonds.push(bond)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Необходимо заполнить автоузлы\r\n\r\n\t\tcurEntity.nodes.forEach(node => {\r\n\t\t\tif (node.bAuto) {\r\n\t\t\t\t// Автоматический узел всегда содержит углерод\r\n\t\t\t\tnode.items[0] = new ChemNodeItem(MenTbl.C)\r\n\t\t\t\tn = node.bonds.reduce((acc, bond) => acc + bond.N, 0)\t// сума кратностей связей, входящих в узел\r\n\t\t\t\tif (n < 4) {\r\n\t\t\t\t\t// Добавить нужное число атомов водорода\r\n\t\t\t\t\tlet item = new ChemNodeItem(MenTbl.H)\r\n\t\t\t\t\titem.n = 4 - n\r\n\t\t\t\t\tnode.items[1] = item\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\t// Распознать начало очередного узла в описании реагента. Если нет, вернуть -1\r\n\tfunction parseNode() {\r\n\t\tif (curNode && !curNode.pB)\r\n\t\t\tcurNode.pB = pos\r\n\t\titemPos0 = pos\r\n\t\t// Элемент\r\n\t\tif (c >= 'A' && c <= 'Z') {\r\n\t\t\t// Извлечь первый заглавный символ элемента. Следующие должны быть маленькими\r\n\t\t\treturn  setState('agentElem', 1)\r\n\t\t}\r\n\r\n\t\t// Краткое описание связи\r\n\t\tif (BondDefMap[c]) {\r\n\t\t\tcreateBondShort()\r\n\t\t\treturn setState(st_agentMid)\r\n\t\t}\r\n\r\n\t\tswitch (c) {\r\n\t\tcase '`':\r\n\t\t\t\t// Признак изменения поведения следующей конструкции\r\n\t\t\treturn bNegChar = 1\r\n\t\tcase '$': // Функция\r\n\t\t\treturn setState('funcName', 1)\r\n\t\tcase '{':\t// начало абстрактного элемента\r\n\t\t\treturn setState('custom', 1)\r\n\t\tcase '^':\t// заряд узла\r\n\t\t\treturn setState('nCharge', 1)\r\n\t\tcase '#':\r\n\t\t\treturn setState('nodeRef', 1)\r\n\t\tcase ';': // Конец цепочки\r\n\t\t\tcloseBond()\r\n\t\t\tcloseNode()\r\n\t\t\tprevBond = 0\r\n\t\t\tchainSys.closeChain()\r\n\t\t\t\t//newChain();\r\n\t\t\treturn setState('agentSpace', 1) // Возможно добавление пробелов\r\n\t\tcase ':':\t// Объявление метки\r\n\t\t\tpos++\r\n\t\t\twhile (pos < textLen && /[\\dA-Z]/i.test(text[pos])) pos++\r\n\t\t\tcheckCurNode()\r\n\t\t\tnodesMap[_substr(itemPos0 + 1)] = curNode\r\n\t\t\treturn setState(st_agentMid)\r\n\t\tcase '<':\r\n\t\t\topenBranch()\r\n\t\t\treturn setState(st_agentMid, 1)\r\n\t\tcase '>':\r\n\t\t\tcloseBranch()\r\n\t\t\treturn setState(st_agentMid, 1)\r\n\t\tcase '(':\r\n\t\t\t\t// Вариант (*\r\n\t\t\tif (nextChar() === '*') {\r\n\t\t\t\topenBranch()\r\n\t\t\t\treturn setState(st_agentMid, 2)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\tcase '\"':\t// Комментарий, который становится частью узла\r\n\t\t\tpos++\r\n\t\t\t{\r\n\t\t\t\tlet item = new makeComment(scanComment())\r\n\t\t\t\tpos++\r\n\t\t\t\taddNodeItem(item)\r\n\t\t\t}\r\n\t\t\treturn setState(st_agentMid)\r\n\t\tcase '*':\r\n\t\t\t\t// Вариант *)\r\n\t\t\tif (nextChar() === ')') {\r\n\t\t\t\tcloseBranch()\r\n\t\t\t\treturn setState(st_agentMid, 2)\r\n\t\t\t}\r\n\t\t\treturn setState('mul', 1)\r\n\t\tcase '_':\r\n\t\t\treturn setState('uniBond', 1)\r\n\t\tcase 'c':\r\n\t\t\tcheckCurNode()\r\n\t\t\treturn setState(st_agentMid, 1)\r\n\t\t}\r\n\t\t// Скобки...\r\n\t\tif (ChemBrBegin.Map[c]) {\t// Открытая скобка\r\n\t\t\t// TODO: Не воспринимается скобка из нескольких символов\r\n\t\t\t// TODO: Если переставить перед switch, то перестаёт работать (* *)\r\n\t\t\topenBracket()\r\n\t\t\treturn setState(st_agentMid, 1)\r\n\t\t}\r\n\t\tif (ChemBrEnd.Lst.indexOf(c) >= 0) {\r\n\t\t\tcloseBracket()\r\n\t\t\treturn setState(st_agentMid)\r\n\t\t}\r\n\t\t// Специальный контроль символов нелатинских алфавитов\r\n\t\tif (/[А-ЯЁ]/i.test(c))\r\n\t\t\terror('Russian element character', { pos:pos, C:c })\r\n\t\tif (c > '\\x7F') {\r\n\t\t\terror('Non-latin element character', { pos:pos, C:c })\r\n\t\t}\r\n\t\treturn -1\r\n\t}\r\n\r\n\t////////////////////////////////////////////////\r\n\t//\t\tУзлы\r\n\tfunction closeNode() {\r\n\t\tif (curNode) {\r\n\t\t\tif (!curNode.pB) curNode.pB = curNodeEnd\r\n\t\t\tcloseNodeItem()\r\n\t\t\tchargeOwner = curNode = 0\r\n\t\t}\r\n\t}\r\n\tfunction createNode(bAuto, pt) {\r\n\t\tcloseNode()\r\n\t\tcheckMiddlePoints()\r\n\t\tlet node = new ChemNode(pt)\r\n\t\tnode.bAuto = bAuto\r\n\t\tchargeOwner = curNode = node\r\n\t\tcurNodeEnd = curNode.pA = itemPos0\r\n\t\tnode.index = curEntity.nodes.length\r\n\t\tcurEntity.nodes.push(node)\r\n\t\taddCmd(node)\r\n\t\tchainSys.addNode(node)\r\n\t\tnodesBranch.push(node) // созданный узел присоединяется к текущей \"ветке\"\r\n\r\n\t\t// Контроль открытой скобки\r\n\t\t// Есть проблема с вложенными скобками, если между ними нет разделителя. Н.р: A[(B - [.nodes=[A,0], (.nodes=[A,B]\r\n\t\tlet i, br\r\n\t\tfor (i in branchStack) {\r\n\t\t\tbr = branchStack[i].o\r\n\t\t\tif (br && !br.nodes[1]) {\r\n\t\t\t\tbr.nodes[1] = curNode\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (i in postNodeInits)\r\n\t\t\tpostNodeInits[i](node)\r\n\r\n\t\t// Контроль закрытой скобки\r\n\t\tbrEndsCtrl(node)\r\n\t\treturn node\r\n\t}\r\n\r\n\tfunction isEmptyNode(node) {\r\n\t\treturn node.bAuto || ChemSys.isEmptyNode(node)\r\n\t}\r\n\r\n\tfunction smartCreateNode(bAuto) {\r\n\t\t// определить координаты нового узла\r\n\t\tlet pt = 0, node\r\n\t\tif (curBond) {\r\n\t\t\t// Возможно, здесь нужно организовать мягкую связь\r\n\t\t\t// Для этого связь должна иметь признак soft и оба узла не автоматические\r\n\t\t\tif (curBond.soft && !bAuto && !isEmptyNode(curBond.nodes[0])) {\r\n\t\t\t\tchainSys.closeSC(0)\r\n\t\t\t} else {\r\n\t\t\t\tpt = curBond.calcPt()\r\n\t\t\t\tcurBond.soft = 0\r\n\t\t\t}\r\n\t\t}\r\n\t\tpt = pt || new Point()\r\n\t\tnode = chainSys.findByPt(pt)\r\n\t\tif (node) {\r\n\t\t\tcurNode = node\r\n\t\t\tnodesBranch.push(node)\r\n\t\t} else {\r\n\t\t\t// Если узла нет, значит создать новый\r\n\t\t\tnode = createNode(bAuto, pt)\r\n\t\t}\r\n\t\tsetBondEnd()\r\n\t\treturn curNode\r\n\t}\r\n\tfunction checkCurNode() {\r\n\t\tif (!curNode)\r\n\t\t\tsmartCreateNode(1)\r\n\t}\r\n\r\n\t// Обработать ссылку на указанный узел H-#C-H  или #O\r\n\tfunction linkNode(node) {\r\n\t\tcheckBranch()\r\n\t\tnode.fixed = 1\r\n\t\t// Здесь есть две ситуации: сращивание цепей или продолжение цепи\r\n\t\t// Зависит от наличия curBond\r\n\t\tlet node0 = curBond ? curBond.nodes[0] : 0\r\n\t\t// Нельзя сращивать, если цепь одна, но подцепи разные (То есть, зацикленная молекула, в центре которой есть мягкие связи)\r\n\t\tif (node0 && !curBond.soft && !(node0.ch === node.ch && node0.sc !== node.sc)) {\r\n\t\t\t// сращивание цепей\r\n\t\t\tchainSys.merge(node0, node, curBond)\r\n\t\t} else {\r\n\t\t\t// Просто назначить текущую цепь\r\n\t\t\tchainSys.setCur(node)\r\n\t\t}\r\n\t\tcurNode = node\r\n\t\tnodesBranch.push(node)\r\n\t\tsetBondEnd()\r\n\t}\r\n\r\n\t//------------------------ Ветки\r\n\tfunction checkBranch() {\r\n\t\t// TODO:\r\n\t}\r\n\tfunction openBranch() {\r\n\t\tcloseBond()\r\n\t\tbranchStack.unshift({ n:curNode, b:curBond, pb:prevBond, pos:itemPos0, nb:nodesBranch })\r\n\t\tnodesBranch = []\t// начать новую ветку\r\n\t}\r\n\tfunction closeBranch() {\r\n\t\tcloseBond()\r\n\t\tcheckMul()\r\n\t\tlet x = branchStack.shift()\r\n\t\tif (!x) {\r\n\t\t\t// Ошибка: Нет открытой скобки\r\n\t\t\terror('Invalid branch close', { pos:pos })\r\n\t\t}\r\n\t\tif (x.o) {\r\n\t\t\t// Ошибка: ветка закрывается до того, как закрыта скобка...\r\n\t\t\terror('Cant close branch before bracket', { pos:pos, pos0:x.pos + 1 })\r\n\t\t}\r\n\t\tcurNode = x.n\r\n\t\tcurBond = x.b\r\n\t\tprevBond = x.pb\r\n\t\tnodesBranch = x.nb\r\n\t\tchainSys.setCur(curNode)\t// вернуть текущую цепь/подцепь (внутри ветки можно создать новую подцепь)\r\n\t}\r\n\t//------------- ЛОКАЛЬНЫЕ СКОБКИ\r\n\tfunction openBracket() {\r\n\t\tchargeOwner = 0\r\n\t\tlet obj = new ChemBrBegin(c)\r\n\t\tobj.setPos(pos, pos + 1)\r\n\t\tlet node0 = curNode\r\n\t\tif (!node0 && branchStack.length) {\r\n\t\t\t// Для случая [(\r\n\t\t\tif (branchStack[0].o) { // Если есть предыдущая скобка\r\n\t\t\t\tnode0 = branchStack[0].o.nodes[0]\r\n\t\t\t}\r\n\t\t}\r\n\t\tobj.nodes[0] = node0\r\n\t\tobj.bond = curBond\r\n\t\tobj.color = curColor\r\n\t\taddCmd(obj)\r\n\t\tbranchStack.unshift({ o:obj, pos:pos })\r\n\t\t// Пока нет связи...\r\n\t\tcloseNode()\r\n\t\tif (!curBond || curBond.soft)\r\n\t\t\tchainSys.closeSC()\t// Если нет соединяющей связи, нужно прекратить цепь\r\n\t}\r\n\r\n\tfunction closeBracket() {\r\n\t\tcheckMul()\r\n\t\tlet br0 = branchStack.shift()\r\n\t\tif (!br0)\r\n\t\t\terror('Invalid bracket close', { pos:pos })\r\n\t\tlet open = br0.o\r\n\t\tif (!open)\r\n\t\t\terror('Cant close bracket before branch', { pos:pos, pos0:br0.pos + 1 })\r\n\t\tlet needCloseChar = ChemBrBegin.Map[open.tx]\r\n\t\tif (needCloseChar !== c)\r\n\t\t\terror('Expected [must] instead of [have]', { must:needCloseChar, have:c, pos:pos, pos0:br0.pos + 1 })\r\n\r\n\t\tlet obj = new ChemBrEnd(c, open)\r\n\t\topen.end = obj\r\n\t\tobj.pA = pos\r\n\t\tfunction setNode0(node) {\r\n\t\t\tobj.nodes[0] = node\r\n\t\t}\r\n\t\tcheckCurNode(0) // возможны негативные последствия\r\n\t\tif (curNode) {\r\n\t\t\tsetNode0(curNode)\r\n\t\t} else {\r\n\t\t\t// Автоузел может не существовать. Нужно оставить в очереди заявку на его заполнение, когда будет создан\r\n\t\t\tpostNodeInits.push(setNode0)\r\n\t\t}\r\n\t\tobj.color = open.color\t// Цвет закрытой скобки такой же, как у открытой\r\n\r\n\t\t// Определить \"текстовость\" скобок\r\n\t\tlet lst = curEntity.cmds, i = lst.length, txVis = new IsNonText()\r\n\t\taddCmd(obj)\r\n\t\twhile (!txVis.ok && lst[i] !== open) {\r\n\t\t\tlst[i].walk(txVis)\r\n\t\t\ti--\r\n\t\t}\r\n\t\topen.bTxt = obj.bTxt = !txVis.ok\r\n\r\n\r\n\t\t// Добавить скобку в список для закрытия\r\n\t\tbracketEnds.unshift(obj)\r\n\r\n\t\t// Извлечение коэффициента и заряда\r\n\t\tpos++\r\n\t\tlet k = scanKoeff()\r\n\t\tif (k !== null)\r\n\t\t\tobj.n = k\r\n\t\tobj.pB = pos\r\n\r\n\t\tchargeOwner = obj\r\n\t}\r\n\r\n\tfunction brEndsCtrl(node) {\r\n\t\tlet i, brEnd\r\n\t\tfor (i in bracketEnds) {\r\n\t\t\tbrEnd = bracketEnds[i]\r\n\t\t\tif (!brEnd.nodes[1]) brEnd.nodes[1] = node\r\n\t\t}\r\n\t\tbracketEnds.length = 0\r\n\t}\r\n\r\n\r\n\t//------------ СВЯЗИ ---------------\r\n\t// Назначить curNode концом curBond (если она есть) и очистить связь\r\n\tfunction setBondEnd(bRef) {\r\n\t\t// Если есть связь, завершить её\r\n\t\tif (curBond) {\r\n\t\t\tcurBond.nodes[1] = curNode\r\n\t\t\t/*\r\n\t\t\t // Возможно, связь мягкая\r\n\t\t\t if (curBond.soft) {\r\n\t\t\t // Если curNode получен по ссылке, то не нужно его переносить в новую подцепь\r\n\t\t\t chainSys.closeSC(bRef?0:curNode);\r\n\t\t\t }\r\n\t\t\t //curBond = 0;\r\n\t\t\t */\r\n\t\t\tcloseBond()\r\n\t\t}\r\n\t}\r\n\r\n\tfunction closeBond() {\r\n\t\tif (curBond) {\r\n\t\t\tif (!curBond.nodes[1]) {\r\n\t\t\t\tsmartCreateNode(1)\r\n\t\t\t}\r\n\t\t\tcurBond = 0\r\n\t\t}\r\n\t}\r\n\r\n\t// Самая низкуровневая функция создания связи\r\n\tfunction createBondUni(pa) {\r\n\t\tlet bond = new ChemBond()\r\n\t\tbond.setPos(pa, pos)\r\n\t\taddCmd(bond)\r\n\t\tcurEntity.bonds.push(bond)\r\n\t\tif (curColor)\r\n\t\t\tbond.color = curColor\r\n\t\treturn bond\r\n\t}\r\n\r\n\tfunction setCommonBondProps(bond, def) {\r\n\t\tbond.align = def.align || dblAlignMode // x,l,r,m - перекрещенная или смещённая связь\r\n\t\tif (def.H && bond.N === 1) {\r\n\t\t\tbond.style = ':'\r\n\t\t}\r\n\t\tif (def.C) {\t// координационная связь = coordinate bond = dative covalent bond =Dipolar bond\r\n\t\t\tswitch (def.C) {\r\n\t\t\tcase '-':\r\n\t\t\t\tbond.arr0 = 1; break\r\n\t\t\tcase '+':\r\n\t\t\t\tbond.arr0 = bond.arr1 = 1; break\r\n\t\t\tdefault:\r\n\t\t\t\tbond.arr1 = 1\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (def['<']) bond.arr0 = 1\t// стрелка против направления связи\r\n\t\tif (def['>']) bond.arr1 = 1\t// стрелка по направлению связи\r\n\t\tif (def['~']) def.S = '~'\t// извилистая линия (рацемическая связь, н.р. D-глюкопираноза)\r\n\r\n\t\t// Явное определение стилей перекрывает ранее назначенный стиль\r\n\t\tif (def.S) {\r\n\t\t\tif (/^..[lrm]$/i.test(def.S)) {\r\n\t\t\t\t// для стиля может быть задан режим выравнивания, н.р. |:L\r\n\t\t\t\tbond.style = def.S.slice(0, 2)\r\n\t\t\t\tbond.align = def.S[2]\r\n\t\t\t} else {\r\n\t\t\t\tbond.style = def.S\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (bond.align)\r\n\t\t\tbond.align = bond.align.toLowerCase()\r\n\r\n\t\tbond.brk = !bond.soft\r\n\t}\r\n\r\n\t// def:\r\n\t//  pt - шаг связи\r\n\t//  soft - мягкая связь\r\n\t//  tx - text\r\n\t//  N - кратность\r\n\t//  slope\r\n\tfunction createBondStd(def, pA) {\r\n\t\tcloseBond()\r\n\t\tcheckCurNode()\t// Если текущего узла нет, нужно создать автоузел\r\n\t\tlet bond = createBondUni(pA || itemPos0 - bNegChar)\r\n\t\tbond.pt = def.pt\r\n\t\tbond.nodes[0] = curNode\r\n\t\tcloseNode()\r\n\t\tif (def.soft)\r\n\t\t\tbond.soft = 1\r\n\t\tbond.tx = def.tx\r\n\t\tbond.N = def.N\r\n\t\tbond.slope = def.slope// || 1;\r\n\t\tcurBond = bond\r\n\t\tprevBond = curBond\r\n\r\n\t\t// Скобки...\r\n\t\tif (bracketEnds.length) {\r\n\t\t\tbracketEnds[0].bond = bond\r\n\t\t\tbracketEnds.length = 0\r\n\t\t}\r\n\r\n\t\t// Связь считается текстовой, если она расположена горизонтально и имеет длину =1\r\n\t\tbond.bText = Point.is0(Math.abs(def.pt.x) - 1) && Point.is0(def.pt.y)\r\n\t\tif (def.T)\r\n\t\t\tbond.tx = def.T\r\n\r\n\t\t// толщина концов связей\r\n\t\t// толщина связей\r\n\t\tfunction setWidth(id, sign, glb) {\r\n\t\t\tlet val = def[id]\r\n\t\t\tif (val) {\r\n\t\t\t\tif (val === '-') {\r\n\t\t\t\t\tdef.w0 = sign\r\n\t\t\t\t\tdef.w1 = 0\r\n\t\t\t\t} else if (val === '2') {\r\n\t\t\t\t\tdef.w0 = def.w1 = sign\r\n\t\t\t\t} else if (val === '1' || val === '0') {\r\n\t\t\t\t\tdef.w0 = def.w1 = 0\r\n\t\t\t\t} else if (val === '+') {\r\n\t\t\t\t\tdef.w0 = 0\r\n\t\t\t\t\tdef.w1 = sign\r\n\t\t\t\t} else val = 0\r\n\t\t\t\tif (val && glb) {\r\n\t\t\t\t\tcurWidth = def.w1\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn val\r\n\t\t}\r\n\t\tsetWidth('w', 1) || setWidth('d', -1) || setWidth('W', 1, 1) || setWidth('D', -1, 1)\r\n\t\tif (def.w0 || def.w1) {\r\n\t\t\tbond.w0 = def.w0\r\n\t\t\tbond.w1 = def.w1\r\n\t\t}\r\n\r\n\t\tsetCommonBondProps(bond, def)\r\n\r\n\t\t// Загрузка промежуточных точек\r\n\t\tif (middlePoints.length) {\r\n\t\t\tbond.midPt = []\r\n\t\t\tbond.pA = middlePoints[0].pos\r\n\t\t\tlet pt, i, lastPt = bond.pt.clone()\r\n\t\t\tfor (i in middlePoints) {\r\n\t\t\t\tbond.midPt.push(pt = middlePoints[i].pt)\r\n\t\t\t\tbond.pt.addi(pt)\r\n\t\t\t}\r\n\t\t\tbond.midPt.push(lastPt)\r\n\t\t\tmiddlePoints.length = 0\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Возможен поиск координат для указанных вершин\r\n\tfunction toNumCoord(src, axis, apos) {\r\n\t\t// description _(x) => {x:true}\r\n\t\tif (!src || src === true) return 0\r\n\t\tif (src.charAt(0) === '#') {\r\n\t\t\t// Привязка к другим узлам. Номера узлов через ;\r\n\t\t\tlet lnkLst = src.slice(1).split(';'), sum = 0, i, nd, ipos = apos + 1\r\n\t\t\tfor (i in lnkLst) {\r\n\t\t\t\tnd = findNodeEx(lnkLst[i], ipos)\r\n\t\t\t\tsum += nd.pt[axis]\r\n\t\t\t\tipos += lnkLst[i].length + 1\r\n\t\t\t}\r\n\t\t\tsum /= lnkLst.length\r\n\t\t\tcheckCurNode()\r\n\t\t\treturn sum - curNode.pt[axis]\r\n\t\t}\r\n\t\treturn toNum(src, apos)\r\n\t}\r\n\r\n\r\n\t// создать смещение для нового узла полигона\r\n\t// cw = 1/-1 = по или против часовой стрелки\r\n\t// cnt - количество углов (граней) полигона\r\n\t// dstPt - смещение (используется для повышения эффективности, чтобы не создавать лишний объект)\r\n\t// len - длина связи ТОЛЬКО для случая, когда отсутствует предыдущая связь\r\n\tfunction createPolygonStep(cw, cnt, dstPt, len) {\r\n\t\t// dstPt = dstPt  || new Point() // - never used\r\n\t\tif (!prevBond) {\r\n\t\t\tdstPt.init(len, 0)\r\n\t\t\treturn dstPt\r\n\t\t}\r\n\t\t//checkCurNode(); - uniBond\r\n\t\tlet p1 = curNode.pt,\r\n\t\t\tp0 = prevBond.nodes[0].pt,\r\n\t\t\tdist = p1.dist(p0),\r\n\t\t\tca = Math.PI * 2 / cnt,\r\n\t\t\ta0 = p1.subx(p0).polarAngle(),\r\n\t\t\tA = a0 + cw * ca\r\n\t\tdstPt.fromRad(A).muli(dist)\r\n\t\treturn dstPt\r\n\t}\r\n\r\n\r\n\t// Вычислить координаты из описания\r\n\tfunction calcPosition(def, defPos) {\r\n\t\tlet pt = new Point(), val, len = def.L\r\n\t\tif (len) {\r\n\t\t\tlen = toNum(len, defPos.L)\r\n\t\t} else {\r\n\t\t\tlen = stdLen\r\n\t\t}\r\n\t\tfunction fromAngle(a) {\r\n\t\t\tpt.fromDeg(a).muli(len)\r\n\t\t}\r\n\t\t// взаимоисключаются описания: p, P, a, A\r\n\t\tif ('p' in def) {\r\n\t\t\t// Использование координат существующих узлов\r\n\t\t\t// example: p1;-1\r\n\t\t\t// Без #\r\n\t\t\tcheckCurNode()\r\n\t\t\tlet ndl, k, lbl, lblLst = def.p.split(';'), ipos = defPos.p\r\n\t\t\tfor (k in lblLst) {\r\n\t\t\t\tndl = findNodeEx(lbl = lblLst[k], ipos)\r\n\t\t\t\tpt.addi(ndl.pt)\r\n\t\t\t\tipos += lbl.length + 1\r\n\t\t\t}\r\n\t\t\tpt.muli(1 / lblLst.length)\r\n\t\t\tpt.subi(curNode.pt)\r\n\t\t} else if ('P' in def) {\r\n\t\t\tval = def.P === true ? 5 : (+def.P || 5)\r\n\t\t\tcreatePolygonStep(val < 0 ? -1 : 1, Math.abs(val), pt, len)\r\n\t\t} else if ('a' in def) {\r\n\t\t\tlet a = 0\r\n\t\t\tif (prevBond) {\r\n\t\t\t\tcheckCurNode()\r\n\t\t\t\tlet dif = curNode.pt.subx(prevBond.nodes[0].pt)\r\n\t\t\t\ta = dif.polarAngle() * 180 / Math.PI\r\n\t\t\t}\r\n\t\t\ta += toNum(def.a, defPos.a)\r\n\t\t\tfromAngle(a)\r\n\t\t} else if ('A' in def) {\r\n\t\t\tfromAngle(toNum(def.A, defPos.A))\r\n\t\t}\r\n\t\t// значения x, y могут быть прибавлены к другим способам описания координат\r\n\t\tval = def.x\r\n\t\tif (val) {\r\n\t\t\tpt.x += toNumCoord(val, 'x', defPos.x)\r\n\t\t}\r\n\t\tval = def.y\r\n\t\tif (val) {\r\n\t\t\tpt.y += toNumCoord(val, 'y', defPos.y)\r\n\t\t}\r\n\t\treturn pt\r\n\t}\r\n\r\n\tfunction makeDefFromArgs(args, argsPos, def, defPos) {\r\n\t\tlet i, a, key, val\r\n\t\tfor (i in args) {\r\n\t\t\ta = args[i]\r\n\t\t\tkey = a[0]\r\n\t\t\tval = a.slice(1)\r\n\t\t\tdef[key] = val || true\r\n\t\t\tdefPos[key] = argsPos[i] + 1\r\n\t\t}\r\n\t}\r\n\r\n\t// Построить универсальную связь\r\n\tfunction createBondFull(pa, args, argsPos) {\r\n\t\tlet def = { tx:'_', N: 1, w0: curWidth, w1: curWidth }, defPos = {}\r\n\t\tmakeDefFromArgs(args, argsPos, def, defPos)\r\n\r\n\t\t// Перекрещенная двойная связь или режимы выравнивания L, R, M\r\n\t\tif (/^2[xlrm]$/i.test(def.N)) {\r\n\t\t\tdef.align = def.N[1]\r\n\t\t\tdef.N = 2\r\n\t\t} else def.N = +def.N\r\n\r\n\t\tcheckCurNode() // Иначе неправильно считается позиция x#-1;1\r\n\t\tdef.pt = calcPosition(def, defPos)\r\n\r\n\t\tcreateBondStd(def, pa)\r\n\t}\r\n\r\n\t// дополнительные настройки из суффикса\r\n\tfunction loadSuffix(def) {\r\n\t\twhile (pos < textLen) {\r\n\t\t\tc = text[pos]\r\n\t\t\tswitch (c) {\r\n\t\t\tcase '0':\t// пустая связь\r\n\t\t\tcase 'o':\r\n\t\t\t\tdef.N = 0\r\n\t\t\t\tbreak\r\n\t\t\tcase 'h':\r\n\t\t\t\tdef.H = 1\r\n\t\t\t\tbreak\r\n\t\t\tcase 'w':\r\n\t\t\t\tdef.w = (def.w === '+') ? '-' : '+'\r\n\t\t\t\tbreak\r\n\t\t\tcase 'd':\r\n\t\t\t\tdef.d = (def.d === '+') ? '-' : '+'\r\n\t\t\t\tbreak\r\n\t\t\tcase 'x':\r\n\t\t\t\tdef.align = 'x'\r\n\t\t\t\tbreak\r\n\t\t\tcase '~':\r\n\t\t\t\tdef.S = '~'\r\n\t\t\t\tbreak\r\n\t\t\tcase 'v':\r\n\t\t\t\tif (!def['>']) def['>'] = 1\r\n\t\t\t\telse if (!def['<']) {\r\n\t\t\t\t\tdef['<'] = 1\r\n\t\t\t\t\tdef['>'] = 0\r\n\t\t\t\t}\r\n\t\t\t\tbreak\r\n\t\t\tdefault:\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tpos++\r\n\t\t}\r\n\t}\r\n\r\n\t// Создание связи-ребра полигона _p или _q\r\n\t// type = p|q\r\n\tfunction createEdgeBond(type, pa) {\r\n\t\tlet def = { N:1, pt:new Point() }, vertexCnt, j\r\n\t\tpos++\r\n\t\tif (text[pos] === type) {\t// повтор типа означает двойную связь\r\n\t\t\tdef.N++\r\n\t\t\tpos++\r\n\t\t}\r\n\t\tj = pos\r\n\t\twhile (pos < textLen && isDigit(text[pos])) pos++\r\n\t\tvertexCnt = j === pos ? 5 : +text.substring(j, pos)\r\n\r\n\t\tcreatePolygonStep(type === 'q' ? -1 : 1, vertexCnt, def.pt, stdLen)\r\n\t\tloadSuffix(def)\r\n\r\n\t\tcreateBondStd(def, pa)\r\n\t}\r\n\r\n\t// Создание промежуточной точки для изогнутой линии\r\n\tfunction createMiddlePoint() {\r\n\t\tlet p0 = pos - 1\r\n\t\tpos++\r\n\t\tif (text[pos] !== '(') {\r\n\t\t\terror(\"Expected '(' after [S]\", { pos:pos - 1, S:'_m' })\r\n\t\t}\r\n\t\tpos++\r\n\t\tlet args = [], argsPos = [], def = {}, defPos = {}, pt\r\n\t\tscanArgs(args, argsPos)\r\n\t\tmakeDefFromArgs(args, argsPos, def, defPos)\r\n\t\tcheckCurNode() // на всякий случай\r\n\t\tpt = calcPosition(def, defPos)\r\n\t\tmiddlePoints.push({ pt:pt, pos:p0, pos1:pos })\r\n\t}\r\n\r\n\t// Циклическая пи-связь (бензол с кольцом)\r\n\tfunction createRing(pa) {\r\n\t\tlet n = nodesBranch.length, j = n - 2, bond\r\n\t\tif (n < 3)\r\n\t\t\terror('Cant create ring', { pos:pa })\r\n\t\t// Поиск совпавшей вершины\r\n\t\twhile (j >= 0 && nodesBranch[j] !== curNode) j--\r\n\t\tif (j < 0)\r\n\t\t\terror('Cant close ring', { pos:pa })\r\n\t\tbond = createBondUni(pa)\r\n\t\tbond.nodes.length = 0\r\n\t\tbond.tx = bond.ext = 'o'\r\n\t\tbond.N = 1\r\n\t\tfor (j++; j < n; j++) {\r\n\t\t\tbond.nodes.push(nodesBranch[j])\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Конструкция _s для ввода связи через несколько узлов\r\n\tfunction createPolyBond(args, argsPos, pa) {\r\n\t\tlet def = {}, defPos = {}, bond, nodes\r\n\t\tmakeDefFromArgs(args, argsPos, def, defPos)\r\n\t\tbond = createBondUni(pa)\r\n\t\tbond.tx = bond.ext = 's'\r\n\t\tnodes = bond.nodes\r\n\t\tnodes.length = 0\r\n\t\tbond.o = def.o\t// Признак цикличности, заданный в описании связи\r\n\t\tif (def.N) bond.N = +def.N\r\n\t\tsetCommonBondProps(bond, def)\r\n\t\tfunction parseListDef(listDef) {\r\n\t\t\tlet nodes = bond.nodes,\r\n\t\t\t\tipos = defPos['#'],\r\n\t\t\t\ti, j, pieces = listDef.split(';'),\r\n\t\t\t\tintDef, node, node2\r\n\t\t\tfor (i in pieces) {\r\n\t\t\t\tintDef = pieces[i].split(':')\r\n\t\t\t\tif (intDef.length === 1) {\r\n\t\t\t\t\t// Один узел\r\n\t\t\t\t\tnodes.push( findNodeEx(intDef[0], ipos) )\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Интервал узлов\r\n\t\t\t\t\tnode = findNodeEx(intDef[0], ipos)\r\n\t\t\t\t\tnode2 = findNodeEx(intDef[1], ipos + intDef[0].length + 1)\r\n\t\t\t\t\tif (node.index > node2.index) {\r\n\t\t\t\t\t\t// Если в обратном порядке, меняем местами\r\n\t\t\t\t\t\t[node2, node] = [node, node2]\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet agentNodes = curEntity.nodes\r\n\t\t\t\t\tfor (j = node.index; j < agentNodes.length; j++) {\r\n\t\t\t\t\t\tnodes.push(agentNodes[j])\r\n\t\t\t\t\t\tif (node2 === agentNodes[j])\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tipos += pieces[i].length + 1\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction autoFind() {\r\n\t\t\tlet j = nodesBranch.length - 1, node0 = 0, node\r\n\t\t\twhile (j >= 0) {\r\n\t\t\t\tnodes.push(node = nodesBranch[j])\r\n\t\t\t\tif (!node0)\r\n\t\t\t\t\tnode0 = node\r\n\t\t\t\telse if (node === node0)\r\n\t\t\t\t\tbreak\t// кольцо замкнулось\r\n\t\t\t\tj--\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet n, listDef = def['#']\r\n\t\tif (listDef) {\r\n\t\t\t// Разбор описания списка узлов\r\n\t\t\tparseListDef(listDef)\r\n\t\t} else {\r\n\t\t\t// Включаем все узлы подряд с конца. Либо до замыкания кольца, либо до начала ветки\r\n\t\t\tautoFind()\r\n\t\t}\r\n\t\tn = nodes.length\r\n\t\t// Признак цикличности: число узлов 4 или больше И первый узел в цепи совпадает с последним\r\n\t\tif (n > 3 && nodes[0] === nodes[n - 1]) {\r\n\t\t\tnodes.length = n - 1 // Убрать последний узел\r\n\t\t\tbond.o = 1\r\n\t\t}\r\n\t\t//bond.style = def.S;\r\n\t}\r\n\r\n\t// Строим числовые характеристики связей. Они соответствуют циферблату:\r\n\t// неоткорректированные наклонные ближе к горизонтали (2,4,8,10)\r\n\t// откорректированные ближе к вертикали (1,5,7,11)\r\n\t// 1=откорректированная связь /, 2=неоткорректированная связь /,\r\n\t// 3= -, 4=не корректированная \\, 5= корректированная \\\r\n\t// 6= |, 7= не корректированная `/, 8=корректированная `/, 9= `-,\r\n\t// 10= не корректированная `\\, 11 = корректированная `\\, 12 = `|\r\n\r\n\tfunction calcSlopeId(slope, bNeg, bHoriz, bCorr) {\r\n\t\t//let s = bond.slope, b=bond.bNeg;\r\n\t\tif (!slope) { // Либо горизонтальная, либо вертикальная\r\n\t\t\tif (bHoriz) {\r\n\t\t\t\treturn bNeg ? 9 : 3\r\n\t\t\t} else {\r\n\t\t\t\treturn bNeg ? 12 : 6\r\n\t\t\t}\r\n\t\t}\r\n\t\t// остаются наклонные, у которых s 1 или -1\r\n\t\tif (slope > 0) { // 4,5,10,11\r\n\t\t\tif (bCorr) { // 5,11\r\n\t\t\t\treturn bNeg ? 11 : 5\r\n\t\t\t} else { // 4,10\r\n\t\t\t\treturn bNeg ? 10 : 4\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 1,2, 7,8\r\n\t\tif (bCorr) {\r\n\t\t\treturn bNeg ? 7 : 1\r\n\t\t}\r\n\t\treturn bNeg ? 8 : 2\r\n\t}\r\n\tfunction bondSlopeId(bond) {\r\n\t\treturn calcSlopeId(bond.slope, bond.bNeg, Point.is0(bond.pt.y), bond.bCorr)\r\n\t}\r\n\r\n\t// Создание связи из краткого описания\r\n\tfunction createBondShort() {\r\n\t\t// Извлечение максимально длинной связи\r\n\t\t// TODO: этот алгоритм можно ускорить, если заранее построить дерево проверок\r\n\t\tlet i, l, maxLen = 0, bestId, bestDef, n1\r\n\t\tfor (i in BondDefs) {\r\n\t\t\tif (text.indexOf(i, pos) === pos) {\r\n\t\t\t\tl = i.length\r\n\t\t\t\tif (l > maxLen) {\r\n\t\t\t\t\tmaxLen = l\r\n\t\t\t\t\tbestId = i\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tbestDef = BondDefs[bestId]\r\n\t\tpos += maxLen\r\n\t\t// 0=кратность, 1=угол, 2=знак уклона, 3=признак мягкой связи, 4=текст\r\n\t\tlet slope = bestDef[2], angle0 = bestDef[1],\r\n\t\t\tdef = { N:bestDef[0], slope:slope, soft:bestDef[3], tx:bestDef[4] || bestId }\r\n\t\tloadSuffix(def)\r\n\r\n\t\tlet linkSlope = userSlope || defaultSlope,\r\n\t\t\tangle = bestDef[1] + slope * linkSlope\r\n\r\n\t\tlet bsid1 = 0, bsid2 = 0,\r\n\t\t\tprevL = prevBond,\r\n\t\t\tbCorr = 0,\r\n\t\t\tbHoriz = !angle0 && !slope\r\n\t\t// Автокоррекция. Шаг 1.\r\n\t\t// Не используется, если угол наклона явно указан при помощи $slope\r\n\t\tif (!userSlope && prevL && prevL.bAuto) {\r\n\t\t\tbsid1 = bondSlopeId(prevL)\r\n\t\t\tbsid2 = calcSlopeId(slope, bNegChar, bHoriz, 0)\r\n\t\t\tif (((bsid1 === 3 || bsid1 === 9) && slope) ||\t\t// horiz, slope\r\n\t\t\t\t((bsid1 === 8 || bsid1 === 7) && bsid2 === 4) ||\t\t// `/\\\r\n\t\t\t\t((bsid1 === 4 || bsid1 === 5) && bsid2 === 8) ||\t\t// \\`/\r\n\t\t\t\t((bsid1 === 10 || bsid1 === 11) && bsid2 === 2) ||\t// `\\/\r\n\t\t\t\t((bsid1 === 1 || bsid1 === 2) && bsid2 === 10)\t\t//  /`\\\r\n\t\t\t) {\r\n\t\t\t\tangle = bestDef[1] + slope * Math.PI / 3\r\n\t\t\t\tbCorr = 1\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (bNegChar)\r\n\t\t\tangle += Math.PI\r\n\r\n\t\tdef.pt = new Point().fromRad(angle).muli(stdLen)\r\n\r\n\t\tcreateBondStd(def)\r\n\r\n\t\tcurBond.bAuto = 1\r\n\t\tcurBond.bCorr = bCorr\r\n\t\tcurBond.bNeg = bNegChar\r\n\t\tbNegChar = 0\r\n\t\tn1 = curBond.nodes[0]\r\n\r\n\t\t// Коррекция предыдущей связи:\r\n\t\t// Коррекция разрешена, есть предыдущая связь, она автоматическая и не корректировалась\r\n\t\tif (!userSlope && prevL && prevL.bAuto && !prevL.bCorr && !n1.fixed) {\r\n\t\t\t// Либо сочетание наклонной связи с горизонтальной.\r\n\t\t\t// Либо сочетание разнонаправленных наклонных связей\r\n\t\t\tif (((bsid1 === 4 || bsid1 === 5) && bsid2 === 8) ||  // \\`/\r\n\t\t\t\t((bsid1 === 2 || bsid1 === 1) && bsid2 === 10) || // /`\\\r\n\t\t\t\t((bsid1 === 10 || bsid1 === 11) && bsid2 === 2) || // `\\/\r\n\t\t\t\t((bsid1 === 8 || bsid1 === 7) && bsid2 === 4) || // `/\\\r\n\t\t\t\t((bsid1 === 10 || bsid1 === 8 || bsid1 === 2 || bsid1 === 4) && bHoriz)\r\n\t\t\t) {\r\n\t\t\t\tlet a = prevL.nodes[0].pt,\r\n\t\t\t\t\td = n1.pt.subx(a),\r\n\t\t\t\t\tsx = d.x < 0 ? -1 : 1, sy = d.y < 0 ? -1 : 1,\r\n\t\t\t\t\td1 = new Point(Math.abs(d.y) * sx, Math.abs(d.x) * sy),\r\n\t\t\t\t\tnewPt = d1.addi(a),\r\n\t\t\t\t\tcorr = newPt.subx(n1.pt)\r\n\t\t\t\tprevL.bCorr = 100\r\n\t\t\t\tn1.pt = newPt\r\n\t\t\t\t// возможно, требуется откорректировать боковую ветку...\r\n\t\t\t\t/* TODO: закомментировано временно, пока нет боковых веток\r\n\t\t\t\t let chL=chains[curChain].L;\r\n\t\t\t\t let j=chL.length-2;\r\n\t\t\t\t while (chL[j]!=prevL && j>=0) chL[--j].nodes[1].ufl=0;\r\n\t\t\t\t if (j<chL.length-2) {\r\n\t\t\t\t while (j<chL.length-2) {\r\n\t\t\t\t let ndj=chL[++j].nodes[1];\r\n\t\t\t\t if (!ndj.ufl) {\r\n\t\t\t\t ndj.ufl=1;\r\n\t\t\t\t ndj.pt.addi(corr);\r\n\t\t\t\t }\r\n\t\t\t\t }\r\n\t\t\t\t }\r\n\t\t\t\t */\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t////////////////////////////////////////////////\r\n\t// Элементы узлов\r\n\r\n\tfunction getLastItem() {\r\n\t\tlet lst = curNode.items, L = lst.length\r\n\t\treturn L ? lst[L - 1] : 0\r\n\t}\r\n\tfunction closeNodeItem() {\r\n\t\t//let item=getLastItem();\r\n\t\t//if (item && !item.pB) item.pB=pos;\r\n\t}\r\n\tfunction addNodeItem(obj) {\r\n\t\tif (bracketEnds.length) {\r\n\t\t\tcloseNode()\r\n\t\t\tchainSys.closeSC()\r\n\t\t}\r\n\t\tif (!curNode)\r\n\t\t\tsmartCreateNode()\r\n\t\tcloseNodeItem()\r\n\t\tlet item = new ChemNodeItem(obj)\r\n\t\titem.setPos(itemPos0, pos)\r\n\t\tcurNode.items.push(item)\r\n\t\tcurNodeEnd = pos\r\n\r\n\t\tif (bNegChar) {\t// Назначить явным образом центральный элемент узла\r\n\t\t\titem.bCenter = true\r\n\t\t\tbNegChar = 0\r\n\t\t}\r\n\r\n\t\t// Предыдущие настройки...\r\n\t\titem.M = specMass\r\n\t\tspecMass = 0\r\n\t\titem.atomNum = bAtomNum\r\n\t\tbAtomNum = 0\r\n\t\tif (curItemColor1) {\r\n\t\t\titem.color = curItemColor1\r\n\t\t\tcurItemColor1 = 0\r\n\t\t} else if (curItemColor) {\r\n\t\t\titem.color = curItemColor\r\n\t\t} else {\r\n\t\t\titem.color = curColor\r\n\t\t}\r\n\t\tif (curAtomColor1) {\r\n\t\t\titem.atomColor = curAtomColor1\r\n\t\t\tcurAtomColor1 = 0\r\n\t\t} else {\r\n\t\t\titem.atomColor = curAtomColor\r\n\t\t}\r\n\t\titem.dots = nextDots\r\n\t\titem.dashes = nextDashes\r\n\t\tnextDots = nextDashes = 0\r\n\r\n\t}\r\n\r\n\t//------------- ссылки\r\n\r\n\t// Найти существующий узел по описанию (номер, обозначение элемента)\r\n\tfunction findNode(ref) {\r\n\t\tlet i, n = +ref, lst = curEntity.nodes\r\n\t\tif (n) {\r\n\t\t\tif (n < 0) { // Отрицательные номера использовать для обратной индексации\r\n\t\t\t\tn += lst.length\r\n\t\t\t\tif (n < 0) return 0\r\n\t\t\t\treturn lst[n]\r\n\t\t\t}\r\n\t\t\tif (n > lst.length) return 0 // Выход за пределы списка\r\n\t\t\treturn lst[--n] // Т.к. нумерация с 1\r\n\t\t}\r\n\r\n\t\t// Возможно, метка...\r\n\t\t// Если была указана метка, совпадающая с обозначением элемента, то метка имеет приоритет выше\r\n\t\tnd = nodesMap[ref]\r\n\t\tif (nd)\r\n\t\t\treturn nd\r\n\r\n\t\t// если указан элемент (возможно с номером)\r\n\t\tlet nodes, nd, elId = ref, el = _findElem(elId)\r\n\t\tif (el) {\r\n\t\t\tnodes = curEntity.nodes\r\n\t\t\tn = nodes.length\r\n\t\t\tfor (i = 0; i < n; i++) {\r\n\t\t\t\tnd = nodes[i]\r\n\t\t\t\tif (nd.items.length === 1 && nd.items[0].obj === el) {\r\n\t\t\t\t\treturn nd\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0\r\n\t}\r\n\tfunction findNodeEx(refId, startPos) {\r\n\t\tlet node = findNode(refId)\r\n\t\tif (!node) error(\"Invalid node reference '[ref]'\", { ref:refId, pos:startPos })\r\n\t\treturn node\r\n\t}\r\n\r\n\r\n\t// Final state machine for syntax analyzer\r\n\tconst fsm = {\r\n\t\tbegin: () => {\r\n\t\t\tskipSpace()\r\n\t\t\tif (pos >= textLen) {\r\n\t\t\t\treturn 0\r\n\t\t\t}\r\n\t\t\t// Previous comment\r\n\t\t\tif (c === '\"') {\r\n\t\t\t\treturn setState('commPre', 1)\r\n\t\t\t}\r\n\t\t\t// Если операция, обрабатываем её\r\n\t\t\tlet r = checkOp()\r\n\t\t\tif (r !== null)\r\n\t\t\t\treturn r\r\n\r\n\t\t\t// Возможно наличие коэффициента\r\n\t\t\tkoeffPrePos = pos\r\n\t\t\tkoeffPre = scanKoeff()\r\n\t\t\tskipSpace()\r\n\t\t\tif (pos === textLen)\r\n\t\t\t\treturn 0\r\n\r\n\t\t\tc = text[pos]\r\n\t\t\t// Здесь возможно открытие суперскобки...\r\n\t\t\tif (c === '(' && isSpace(nextChar())) {\r\n\t\t\t\t_notImpl('Superbracket')\r\n\t\t\t}\r\n\r\n\t\t\t// Иначе считаем, что это начало реагента\r\n\t\t\treturn setState('agent')\r\n\t\t}, // begin\r\n\t\tcommPre: function () {\r\n\t\t\tcommentPrePos = pos\r\n\t\t\tcommentPre = scanComment()\r\n\t\t\treturn setState('begin', 1)\r\n\t\t},\r\n\t\tagent: function () {\r\n\t\t\t// Начало распознавания реагента\r\n\t\t\tcreateEntity(new ChemAgent())\r\n\t\t\topenAgent()\r\n\t\t\treturn setState('agentIn')\r\n\t\t},\r\n\t\tagentIn: function () {\r\n\t\t\tlet res = parseNode()\r\n\t\t\tif (res < 0)\r\n\t\t\t\terror(\"Unknown element character '[C]'\", { C:c, pos:pos })\r\n\t\t\treturn res\r\n\t\t},\r\n\t\tagentMid: function () {\r\n\t\t\tlet res = parseNode()\r\n\t\t\tif (res < 0) {\r\n\t\t\t\t// Конец агента\r\n\t\t\t\tcloseAgent()\r\n\t\t\t\treturn setState('begin')\r\n\t\t\t}\r\n\t\t\treturn res\r\n\t\t},\r\n\t\tagentElem: function () {\r\n\t\t\t// Извлечение элемента. Первая буква уже пройдена, pos указывает на вторую\r\n\t\t\tlet pos0 = pos - 1\r\n\t\t\twhile (pos < textLen && isSmallAlpha(text[pos])) pos++\r\n\t\t\tlet elemId = _substr(pos0),\r\n\t\t\t\tobj = _findElem(elemId)\r\n\t\t\tif (!obj)\r\n\t\t\t\terror(\"Unknown element '[Elem]'\", { pos:pos0, Elem:elemId })\r\n\t\t\taddNodeItem(obj)\r\n\t\t\treturn setState('postItem')\r\n\t\t},\r\n\t\t// Сразу после элемента узла\r\n\t\tpostItem: function () {\r\n\t\t\tlet item, k = scanKoeff()\r\n\t\t\tif (k !== null) {\r\n\t\t\t\titem = getLastItem()\r\n\t\t\t\titem.n = k\r\n\t\t\t\titem.pB = pos\r\n\t\t\t\treturn setState('postItem')\r\n\t\t\t}\r\n\t\t\t// Возможно, степень окисления в скобках\r\n\t\t\tk = scanOxidation()\r\n\t\t\tif (k) {\r\n\t\t\t\titem = getLastItem()\r\n\t\t\t\titem.charge = k\r\n\t\t\t\titem.pB = pos\r\n\t\t\t\treturn setState('postItem')\r\n\t\t\t}\r\n\t\t\tcurNodeEnd = pos\r\n\t\t\treturn setState(st_agentMid)\r\n\t\t},\r\n\t\tfuncName: function () {\r\n\t\t\t// Извлечение имени функции до скобки\r\n\t\t\tlet p0 = pos, name, args = [], argPos = []\r\n\t\t\twhile (pos < textLen && text[pos] !== '(') pos++\r\n\t\t\tif (pos === textLen)\r\n\t\t\t\terror(\"Expected '(' after [S]\", { S:'$', pos: p0 })\r\n\t\t\tname = _substr(p0)\r\n\t\t\tpos++\r\n\t\t\tscanArgs(args, argPos)\r\n\t\t\t// Если имя функции не найдено, функция игнорируется\r\n\t\t\t// с целью совместимости со следующими версиями\r\n\t\t\tif (funcs[name]) {\r\n\t\t\t\tfuncs[name](args, argPos)\r\n\t\t\t}\r\n\t\t\treturn setState(st_agentMid)\r\n\t\t},\r\n\t\t// Создание абстрактного элемента или радикала\r\n\t\tcustom: function () {\r\n\t\t\tlet p0 = pos, s, radical\r\n\t\t\twhile (pos < textLen && text[pos] !== '}') pos++\r\n\t\t\tif (pos >= textLen)\r\n\t\t\t\terror('Abstract element is not closed', { pos: p0 - 1 })\r\n\t\t\ts = _substr(p0); pos++\r\n\t\t\tradical = ChemRadical.Map[s]\r\n\t\t\taddNodeItem(radical || new ChemCustom(s))\r\n\t\t\treturn setState('postItem')\r\n\t\t},\r\n\t\t// Заряд узла (после ^)\r\n\t\tnCharge: function () {\r\n\t\t\tif (!chargeOwner)\r\n\t\t\t\terror('Expected node declaration before charge', { pos:pos - 1 })\r\n\t\t\tlet p0 = pos, charge = scanCharge()\r\n\t\t\tif (!charge)\r\n\t\t\t\terror('Invalid charge declaration', { pos:p0 })\r\n\t\t\tif (bNegChar) {\t// Наличие ` перед объявлением заряда означает, что заряд нужно вывести слева\r\n\t\t\t\tcharge.bLeft = 1\r\n\t\t\t\tbNegChar = 0\r\n\t\t\t}\r\n\t\t\tchargeOwner.charge = charge\r\n\t\t\treturn setState(st_agentMid)\r\n\t\t},\r\n\t\t// Первый символ ссылки на узел\r\n\t\tnodeRef: function () {\r\n\t\t\tlet p0 = pos, refId, node\r\n\t\t\tif (isDigit(c) || c === '-') {\r\n\t\t\t\t// Извлечение числовой ссылки\r\n\t\t\t\tpos++\r\n\t\t\t\twhile (pos < textLen && isDigit(text[pos])) pos++\r\n\t\t\t} else if (/[A-Z]/i.test(c)) {\r\n\t\t\t\t// Извлечение текстовой ссылки\r\n\t\t\t\tpos++\r\n\t\t\t\twhile (pos < textLen && /^[A-Z\\d]$/i.test(text[pos])) pos++\r\n\t\t\t} else if (isSpace(c)) {\r\n\t\t\t\t// Пропуск\r\n\t\t\t\treturn setState('agentSpace', 1)\r\n\t\t\t}\r\n\t\t\trefId = _substr(p0)\r\n\t\t\tnode = findNodeEx(refId, p0)\r\n\r\n\t\t\t// Установить признак, означающий конец мостика,\r\n\t\t\t// чтобы мягкие связи между уже существующими узлами не сливались\r\n\t\t\t// возможно, стоило переместить в linkNode...\r\n\t\t\tif (curBond)\r\n\t\t\t\tcurBond.brk = 1\r\n\r\n\t\t\tlinkNode(node)\r\n\t\t\treturn setState(st_agentMid)\r\n\t\t},\r\n\t\tagentSpace: function () {\r\n\t\t\twhile(pos < textLen && isSpace(text[pos])) pos++\r\n\t\t\treturn setState(st_agentMid)\r\n\t\t},\r\n\t\tuniBond: function () {\r\n\t\t\tcheckCurNode()\r\n\t\t\tlet pa = pos - 1, args = [], argsPos = [], bCreate = 1\r\n\t\t\tif (c === '(') {\r\n\t\t\t\tpos++\r\n\t\t\t\tscanArgs(args, argsPos)\r\n\t\t\t} else if (c === 'p' || c === 'q') {\r\n\t\t\t\tcreateEdgeBond(c, pa)\r\n\t\t\t\tbCreate = 0\r\n\t\t\t} else if (c === 'm') {\r\n\t\t\t\tcreateMiddlePoint()\r\n\t\t\t\tbCreate = 0\r\n\t\t\t} else if (c === 'o') {\r\n\t\t\t\tpos++\r\n\t\t\t\tcreateRing(pa)\r\n\t\t\t\tbCreate = 0\r\n\t\t\t} else if (c === 's') {\r\n\t\t\t\tif (text[++pos] !== '(')\r\n\t\t\t\t\terror(\"Expected '(' after [S]\", { S:c, pos:pos })\r\n\t\t\t\tpos++\r\n\t\t\t\tscanArgs(args, argsPos)\r\n\t\t\t\tcreatePolyBond(args, argsPos, pa)\r\n\t\t\t\tbCreate = 0\r\n\t\t\t}\r\n\t\t\tif (bCreate)\r\n\t\t\t\tcreateBondFull(pa, args, argsPos)\r\n\t\t\treturn setState(st_agentMid)\r\n\t\t},\r\n\t\tmul: function () {\r\n\t\t\t// Мультипликатор. pos указывает на следующий символ после *\r\n\t\t\tcheckMul()\r\n\t\t\tlet pa = pos - 1,\r\n\t\t\t\tn = scanKoeff(),\r\n\t\t\t\tcmd = new ChemMul(n || 1)\r\n\t\t\tcmd.setPos(pa, pos)\r\n\t\t\taddCmd(cmd)\r\n\t\t\tcloseNode()\r\n\t\t\tchainSys.closeSC()\t// нужно прекратить подцепь\r\n\t\t\tbranchStack.unshift({ m:cmd })\t// внести команду в стек веток со свойством m\r\n\t\t\t// Извлечение произойдёт при закрытии > ), в конце агента или в начале нового мультипликатора\r\n\t\t\treturn setState(st_agentMid)\r\n\t\t}\r\n\r\n\t} // fsm\r\n\r\n\t//////////////////////////////////////////////\r\n\t//\t\tСобственно алгоритм компиляции\r\n\ttry {\r\n\t\t// В различных источниках часто встречается символ, похожий на минус, но с другим кодом...\r\n\t\ttext = text.replace(/−/g, '-')\r\n\t\t// Выполнить препроцесс\r\n\t\ttext = result.src = preProcess(text)\r\n\r\n\t\t// Добавить пробел в конец описания для упрощения алгоритма распознавания\r\n\t\ttext += ' '\r\n\t\ttextLen = text.length\r\n\r\n\t\t// main cycle of syntax analyzer\r\n\t\twhile (pos < text.length) {\r\n\t\t\tc = text[pos]\r\n\t\t\tlet d = fsm[curState]()\r\n\t\t\tpos += d\r\n\t\t}\r\n\t} catch (err) {\r\n\t\tresult.error = (err instanceof ChemError) ? err : new ChemError('Internal error: [msg]', { msg:err.message })\r\n\t}\r\n\r\n\tresult.src0 = text\t// source text\r\n\r\n\treturn result\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/compiler/index.js","/**\r\n * Created by PeterWin on 09.05.2017.\r\n */\r\n\r\n////////////////////////////////////////////////////////////\r\n//\t\tvisitor ChargeCalc\r\n//\tВычисление суммы зарядов узлов\r\n// Example:\r\n//\tvar visitor = new ChargeCalc();\r\n//\texpr.walk(visitor);\r\n//\tvar chargeValue = visitor.result();\r\n\r\n/**\r\n *\r\n * @constructor\r\n */\r\nexport default function ChargeCalc() {\r\n\tlet me = this,\r\n\t\tstack = [0]\r\n\r\n\t/**\r\n\t * @returns {number}\r\n\t */\r\n\tme.result = () => stack[0]\r\n\r\n\tme.agentPre = me.bracketBegin = me.mul = () => {\r\n\t\tstack.unshift(0)\r\n\t}\r\n\tme.agentPost = obj => {\r\n\t\tlet n = stack.shift() * obj.n\r\n\t\tstack[0] += n\r\n\t}\r\n\tme.bracketEnd = obj => {\r\n\t\tlet v = stack.shift()\r\n\t\tif (obj.charge) {\r\n\t\t\t// заряд, указанный для скобки, игнорирует все заряды внутри скобок\r\n\t\t\t// например, для комплексного иона можно указать заряды лигандов, но они считаться не будут\r\n\t\t\tv = obj.charge.val\r\n\t\t}\r\n\t\tstack[0] += v * obj.n\r\n\t}\r\n\tme.nodePost = obj => {\r\n\t\tstack[0] += obj.chargeVal()\r\n\t}\r\n\tme.mulEnd = obj => {\r\n\t\tlet n = stack.shift() * obj.beg.n\r\n\t\tstack[0] += n\r\n\t}\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// src/visitors/ChargeCalc.js","/**\r\n * Created by PeterWin on 07.05.2017.\r\n */\r\n'use strict'\r\nimport ElemList from '../core/ElemList'\r\n\r\n////////////////////////////////////////////////////////////\r\n//\tвизитор для формирования списка элементов из выражения\r\n// Не учитываются коэффициенты агентов.\r\n// Не имеет смысла для выражений, имеющих более одного агента\r\n//\tvar visitor = new ElemListMaker()\r\n\r\n/**\r\n * Visitor for making elements list from expression\r\n * Agents coeffisients are ignored!\r\n * Valid for expression with single agent only!\r\n * Example:\r\n *   let expr = ChemSys.compile('H2O'), visitor = new ElemListMaker()\r\n *   expr.walk(visitor)\r\n *   let elemList = visitor.result()\r\n * @constructor\r\n */\r\nexport default function ElemListMaker() {\r\n\tlet visitor = this,\r\n\t\tstack = [new ElemList()]\r\n\r\n\t/**\r\n\t * Get calculated elements list\r\n\t * @returns {ElemList}\r\n\t */\r\n\tvisitor.result = () => stack[0]\r\n\r\n\tvisitor.agentPre = visitor.itemPre = visitor.bracketBegin = visitor.mul = () => {\r\n\t\tstack.unshift(new ElemList())\r\n\t}\r\n\r\n\tconst pop = obj => {\r\n\t\tlet lst = stack.shift()\r\n\t\tlst.scale(obj.n)\r\n\t\tstack[0].addList(lst)\r\n\t}\r\n\tvisitor.agentPost = visitor.itemPost = visitor.mulEnd = pop\r\n\r\n\tvisitor.bracketEnd = obj => {\r\n\t\t// save charge, what calculated for internal brackets\r\n\t\t// Сохранить заряд, вычисленный для внутренностей скобок\r\n\t\tlet svCharge = stack[0].charge\r\n\t\tpop(obj)\r\n\t\tif (obj.charge) {\r\n\t\t\t// If bracket have specified charge, then ignore calculated charge\r\n\t\t\t// Если для скобки указан отдельный заряд, то вычисленный нужно игнорировать\r\n\t\t\tstack[0].charge += obj.charge.val * obj.n - svCharge\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * before node handler\r\n\t * @param {ChemNode} node\r\n\t */\r\n\tvisitor.nodePost = node => {\r\n\t\tstack[0].charge += node.chargeVal()\r\n\t}\r\n\r\n\t/**\r\n\t * Chemical element handler\r\n\t * @param {ChemAtom} chemElement\r\n\t */\r\n\tvisitor.atom = chemElement => {\r\n\t\tstack[0].addElem(chemElement)\r\n\t}\r\n\tvisitor.custom = obj => {\r\n\t\tstack[0].addCustom(obj.tx)\r\n\t}\r\n\tvisitor.radical = obj => {\r\n\t\tstack[0].addRadical(obj)\r\n\t}\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// src/visitors/ElemListMaker.js","/**\r\n * Created by PeterWin on 06.05.2017.\r\n */\r\n\r\nimport { isAbsK } from '../core'\r\n\r\n/**\r\n * visitor for abstract items detection\r\n * Example\r\n * if (expr.walk(new IsAbstract())) alert('expr is abstract');\r\n * @constructor\r\n */\r\nexport default function IsAbstract() {\r\n\tlet me = this\r\n\tme.ok = false\r\n\tconst testK = k =>\r\n\t\t(me.ok = me.ok || isAbsK(k))\r\n\r\n\t// Агент и элемент узла могут иметь коэффициент ========= Скобка тоже!!!!!!!!!!\r\n\tme.agentPre = me.itemPre = me.bracketEnd = function (obj) {\r\n\t\treturn testK(obj.n)\r\n\t}\r\n\t// Абстрактный элемент\r\n\tme.custom = function () {\r\n\t\treturn me.ok = true\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/visitors/IsAbstract.js","/**\r\n * Created by PeterWin on 07.05.2017.\r\n */\r\n'use strict'\r\n\r\n// visitor для вычисления масс\r\n// Для выражения вычисляется список масс (для каждого агента отдельно)\r\n// Для агента, узла, элемента узла или атома вычисляется одно значение\r\n// Список масс доступен через getList\r\n// Суммарная масса - getSum\r\n// Example:\r\n// var massCalc = new MassCalc();\r\n// expr.walk(massCalc)\r\n// var totalMass = massCalc.getSum()\r\n//\r\n// Внимание! Наличие абстрактных коэффициентов или элементов делает результат непредсказуемым!\r\n// Рекомендуется сначала проверять выражение на абстрактность\r\n\r\nexport default class MassCalc {\r\n\tconstructor() {\r\n\t\tthis.list = []\r\n\t\tthis.stack = [0]\r\n\t\tthis.itemPre = this.bracketBegin = this.mul = this.enter\r\n\t\tthis.itemPost = this.bracketEnd = this.leave\r\n\t}\r\n\r\n\t// Список масс. Если визитор использован для выражения, то для каждого агента будет своя масса. Иначе в списке один элемент.\r\n\t/**\r\n\t * List of mass each agent of expression\r\n\t * @returns {number[]}\r\n\t */\r\n\tgetList() {\r\n\t\treturn this.list.length ? this.list : this.stack\r\n\t}\r\n\r\n\t// Сумма всех масс.\r\n\t// Штатный метод для тех случаев, когда масса ожидается в виде одного числа\r\n\t/**\r\n\t * Calculate total mass of expression\r\n\t * @returns {number}\r\n\t */\r\n\tgetSum() {\r\n\t\t/*\r\n\t\tvar sum=0, i, a=this.getList();\r\n\t\tfor (i in a)\r\n\t\t\tsum += a[i];\r\n\t\treturn sum;\r\n\t\t*/\r\n\t\treturn this.getList().reduce((acc, mass) => acc + mass, 0)\r\n\t}\r\n\r\n\t//--------- internal handlers\r\n\tatom(obj) {\r\n\t\tthis.stack[0] += obj.M\r\n\t}\r\n\r\n\tradical(obj) {\r\n\t\tlet list = obj.items, j = 0, rec\r\n\t\tfor (; j < list.length; j++) {\r\n\t\t\trec = list[j]\r\n\t\t\tthis.stack[0] += rec.elem.M * rec.n\r\n\t\t}\r\n\t}\r\n\r\n\tenter() {\r\n\t\tthis.stack.unshift(0)\r\n\t}\r\n\tleave(obj) {\r\n\t\tlet m = this.stack.shift()\r\n\t\tif (obj.M) m = obj.M\t// Если масса явно указана для элемента ($M), то собственная масса подчинённого объекта игнорируется\r\n\t\tm *= obj.n\t// Умножить массу на количественный коэффициент при элементе\r\n\t\tthis.stack[0] += m\r\n\t}\r\n\tmulEnd(obj) {\r\n\t\tlet m = this.stack.shift()\r\n\t\tm *= obj.beg.n\t// Умножить массу на количественный коэффициент, указанный при объявлении мультипликатора\r\n\t\tthis.stack[0] += m\r\n\t}\r\n\r\n\tagentPost() {\r\n\t\tthis.list.push(this.stack[0])\r\n\t\tthis.stack = [0]\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/visitors/MassCalc.js","/**\r\n * Chains system.\r\n * This is a part of CharChem compiler\r\n * Created 2015-05-26 by PeterWin\r\n */\r\n'use strict'\r\n\r\n/**\r\n * Create instance of sub chain\r\n * @constructor\r\n */\r\nexport function SubChain() {\r\n\tthis.index = SubChain.s_next++\r\n\t/**\r\n\t * private node list\r\n\t * @type {ChemNode[]}\r\n\t */\r\n\tlet nodes = []\r\n\r\n\t/**\r\n\t * Get nodes for this SubChain\r\n\t * @returns {ChemNode[]}\r\n\t */\r\n\tthis.getNodes = () => nodes\r\n\r\n\t/**\r\n\t * Set chain number for all nodes\r\n\t * @param {number} nChain\r\n\t */\r\n\tthis.setCh = nChain =>\r\n\t\tnodes.forEach(node => node.ch = nChain)\r\n\r\n\t/**\r\n\t * Find node by coordinates\r\n\t * @param {Point} pt\r\n\t * @returns {ChemNode|null}\r\n\t */\r\n\tthis.findByPt = pt =>\r\n\t\tnodes.find(node => node.pt.eq(pt)) || null\r\n\r\n\t/**\r\n\t * Add node to sub chain\r\n\t * @param {ChemNode} node\r\n\t */\r\n\tthis.addNode = node => {\r\n\t\tnodes.push(node)\r\n\t\tnode.sc = this.index\r\n\t}\r\n\r\n\tthis.delNode = function (node) {\r\n\t\tlet i = nodes.length\r\n\t\twhile (i > 0) {\r\n\t\t\ti--\r\n\t\t\tif (node === nodes[i]) {\r\n\t\t\t\tnodes.splice(i, 1)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Add nodes list to NON-EMPTY SubChain!\r\n\t * Coordiantes of added nodes moves to delta\r\n\t * @param {ChemNode[]} srcNodes\r\n\t * @param {Point} delta\r\n\t */\r\n\tthis.add = function (srcNodes, delta) {\r\n\t\tlet node0 = nodes[0]\t// SubChain must be non-empty!\r\n\t\tsrcNodes.forEach(node => {\r\n\t\t\tnode.pt.addi(delta)\r\n\t\t\tnode.ch = node0.ch\r\n\t\t\tnode.sc = node0.sc\r\n\t\t\tnodes.push(node)\r\n\t\t})\r\n\t}\r\n}\r\nSubChain.s_next = 1\r\n\r\n// =========================================================\r\n// Chain\r\n\r\nexport function Chain() {\r\n\tthis.index = Chain.s_next++\r\n\t/**\r\n\t * Current subChain\r\n\t * @type {SubChain}\r\n\t */\r\n\tlet curSC = null\r\n\r\n\t/**\r\n\t * Map of subChains by index\r\n\t * @type {Object<number,SubChain>}\r\n\t */\r\n\tlet subChains = {}\r\n\r\n\tthis.getLst = () => subChains\r\n\r\n\t/**\r\n\t * Find node by coordinates in current subChain\r\n\t * @param {Point} pt\r\n\t * @returns {ChemNode|null}\r\n\t */\r\n\tthis.findByPt = pt => !curSC ? null : curSC.findByPt(pt)\r\n\r\n\t/**\r\n\t * Add node to chain and it current subChain\r\n\t * if current subChain is null, then create new subChain\r\n\t * @param {ChemNode} node\r\n\t */\r\n\tthis.addNode = node => {\r\n\t\tif (!curSC) {\r\n\t\t\tcurSC = new SubChain()\r\n\t\t\tsubChains[curSC.index] = curSC\r\n\t\t}\r\n\t\tnode.ch = this.index\r\n\t\tcurSC.addNode(node)\r\n\t}\r\n\r\n\t/**\r\n\t * Close current subChain and remove specified node into new subChain\r\n\t * @param {ChemNode=} node\r\n\t */\r\n\tthis.closeSC = (node = null) => {\r\n\t\tif (curSC && node)\r\n\t\t\tcurSC.delNode(node)\r\n\t\tcurSC = null\r\n\t\tif (node) {\r\n\t\t\tthis.addNode(node)\r\n\t\t\tnode.pt.init(0, 0)\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * get specified subChain\r\n\t * @param {number} n\r\n\t * @returns {SubChain|null}\r\n\t */\r\n\tthis.getSC = n => subChains[n]\r\n\r\n\t/**\r\n\t * Get current subChain\r\n\t * @returns {SubChain|null}\r\n\t */\r\n\tthis.getCurSC = () => curSC\r\n\r\n\t/**\r\n\t * Set current subChain\r\n\t * @param {SubChain} subChain\r\n\t */\r\n\tthis.setCur = subChain => {\r\n\t\tcurSC = subChain\r\n\t}\r\n\r\n\t/**\r\n\t * Delete subChain\r\n\t * @param {number} index\r\n\t * @returns {ChemNode[]|undefined}\r\n\t */\r\n\tthis.delSC = index => {\r\n\t\tlet subChain = subChains[index]\r\n\t\tif (subChain) {\r\n\t\t\tdelete subChains[index]\r\n\t\t\treturn subChain.getNodes()\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * add subChains list\r\n\t * @param {Object<number,SubChain>} subChainsMap\r\n\t */\r\n\tthis.addLst = subChainsMap => {\r\n\t\tfor (let key in subChainsMap) {\r\n\t\t\tlet subChain = subChainsMap[key]\r\n\t\t\tsubChains[subChain.index] = subChain\r\n\t\t\tsubChain.setCh(this.index) // Assign a new chain number to the sub-chain nodes (the number of the sub-chain remains)\r\n\t\t}\r\n\t}\r\n}\r\nChain.s_next = 1\r\n\r\n// ==========================================================\r\n// Chain system\r\n\r\nexport default class ChainSys {\r\n\tconstructor() {\r\n\t\t/**\r\n\t\t * Current chain\r\n\t\t * @type {Chain}\r\n\t\t */\r\n\t\tthis.curCh = null\r\n\r\n\t\t/**\r\n\t\t * Chains map\r\n\t\t * @type {Object<number,Chain>}\r\n\t\t */\r\n\t\tthis.chains = {}\r\n\t}\r\n\r\n\t/**\r\n\t * Add node to ChainSys\r\n\t * @param {ChemNode} node\r\n\t */\r\n\taddNode(node) {\r\n\t\tif (!this.curCh) {\r\n\t\t\tlet chain = this.curCh = new Chain()\r\n\t\t\tthis.chains[chain.index] = chain\r\n\t\t}\r\n\t\tthis.curCh.addNode(node)\r\n\t}\r\n\r\n\t/**\r\n\t * Search for an existing node by coordinates in the current chain and the current sub-chain\r\n\t * @param pt\r\n\t * @returns {*}\r\n\t */\r\n\tfindByPt(pt) {\r\n\t\treturn this.curCh ? this.curCh.findByPt(pt) : null\r\n\t}\r\n\r\n\t/**\r\n\t * Close the current sub-chain and move node to the new one\r\n\t * @param {ChemNode} node\r\n\t */\r\n\tcloseSC(node) {\r\n\t\tif (this.curCh)\r\n\t\t\tthis.curCh.closeSC(node)\r\n\t}\r\n\r\n\tcloseChain() {\r\n\t\tthis.curCh = 0\r\n\t}\r\n\r\n\t/**\r\n\t * Set current chain by node, that owns it\r\n\t * @param {ChemNode} node\r\n\t */\r\n\tsetCur(node) {\r\n\t\tlet ch = this.curCh = this.chains[node.ch]\r\n\t\tch.setCur(ch.getSC(node.sc))\r\n\t}\r\n\r\n\t/**\r\n\t * get current sub-chain\r\n\t * @returns {SubChain|null}\r\n\t */\r\n\tgetCurSC() {\r\n\t\treturn this.curCh ? this.curCh.getCurSC() : null\r\n\t}\r\n\r\n\t/**\r\n\t * Merge\r\n\t * sub-cain srcSc deleted from it chain\r\n\t * @param {ChemNode} srcNode\r\n\t * @param {ChemNode} dstNode\r\n\t * @param {ChemBond} bond\r\n\t */\r\n\tmerge(srcNode, dstNode, bond) {\r\n\t\tlet nSrcCh = srcNode.ch, nSrcSc = srcNode.sc,\r\n\t\t\tnDstCh = dstNode.ch, nDstSc = dstNode.sc\r\n\t\tif (nSrcSc === nDstSc)\r\n\t\t\treturn\r\n\t\tlet\r\n\t\t\tsrcCh = this.chains[nSrcCh],\r\n\t\t\tdstCh = this.chains[nDstCh]\r\n\t\t\t//srcSc = srcCh.getSC(nSrcSc),\r\n\t\tlet dstSc = dstCh.getSC(nDstSc)\r\n\r\n\t\t// Для жесткой связи нужно присоединить исходную подцепь к конечной\r\n\t\tif (!bond.soft) {\r\n\t\t\tlet pos1 = bond.calcPt()\r\n\t\t\tlet delta = dstNode.pt.subx(pos1)\r\n\t\t\tdstSc.add(srcCh.delSC(nSrcSc), delta)\r\n\t\t}\r\n\t\t// Переместить все подцепи из srcCh в dstCh\r\n\t\tdstCh.addLst(srcCh.getLst())\r\n\r\n\t\t// Удалить исходную цепь\r\n\t\tdelete this.chains[nSrcCh]\r\n\t\t// Сменить текущую цепь и подцепь\r\n\t\tthis.curCh = dstCh\r\n\t\tdstCh.setCur(dstSc)\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/compiler/chainSys.js","/**\r\n * Created by PeterWin on 02.05.2017.\r\n */\r\nimport ChemSys, { esc } from '../ChemSys'\r\nimport ChemError from '../core/ChemError'\r\n\r\nexport class Macros {\r\n\t/**\r\n\t * @constructor\r\n\t * @param {string} name\r\n\t */\r\n\tconstructor(name) {\r\n\t\tthis.name = name\r\n\t\tthis.body = ''\t\t // string with @A and & instructions\r\n\t}\r\n}\r\n\r\nconst M1st = /[A-Z]/i\t\t// Possible first characters of macros name\r\nconst TmParam = /^[A-Z][A-Z\\d]*$/i\r\n\r\n// context for preprocessing\r\nexport class Ctx {\r\n\t/**\r\n\t * @constructor\r\n\t * @param {string|Ctx} def\r\n\t * @param {int=} pos\r\n\t */\r\n\tconstructor(def, pos = 0) {\r\n\t\tthis.src = ''\r\n\t\tthis.dst = ''\r\n\t\tthis.stk = []\r\n\t\tthis.pos = pos\r\n\t\t// из другого контекста\r\n\t\tif (def instanceof Ctx) {\r\n\t\t\tthis.src = def.src\r\n\t\t\tthis.pos = def.pos\r\n\t\t} else if (typeof def === 'string') {\r\n\t\t\tthis.src = def\r\n\t\t}\r\n\t}\r\n\r\n\terr(msg, pos) {\r\n\t\tif (pos) {\r\n\t\t\tif (pos < 0) this.pos += pos; else this.pos = pos\r\n\t\t}\r\n\t\tthrow new ChemError(msg)\r\n\t}\r\n\r\n\t/**\r\n\t * Read specified count of characters from context\r\n\t * @param {number=1} count\r\n\t * @returns {string}\r\n\t */\r\n\tn(count = 1) {\r\n\t\tif (count === 0) return ''\r\n\t\tif (this.pos + count > this.src.length)\r\n\t\t\tthis.err('Unexpected end of macros')\r\n\t\tlet startPos = this.pos,\r\n\t\t\tfinishPos = startPos + count,\r\n\t\t\tresult = this.src.slice(startPos, finishPos)\r\n\t\tthis.pos = finishPos\r\n\t\treturn result\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Substring search\r\n\t * @param {string} needle\r\n\t * @param {boolean=} bNoErr\r\n\t * @returns {number|null}\r\n\t */\r\n\ts(needle, bNoErr = false) {\r\n\t\tlet curPos = this.pos,\r\n\t\t\tneedlePos = this.src.indexOf(needle, curPos)\r\n\t\tif (needlePos < 0) {\r\n\t\t\tif (bNoErr) return null\r\n\t\t\tthis.err('Expected ' + needle + ' character in macros')\r\n\t\t}\r\n\t\tthis.pos = needlePos + needle.length\r\n\t\treturn curPos === needlePos ? '' : this.src.slice(curPos, needlePos)\r\n\t}\r\n\r\n\t/**\r\n\t * Is there an end?\r\n\t * @returns {boolean}\r\n\t */\r\n\tend() {\r\n\t\treturn this.pos >= this.src.length\r\n\t}\r\n\r\n\t/**\r\n\t * output to dst\r\n\t * @param {string} text\r\n\t */\r\n\tw(text) {\r\n\t\tthis.dst += text\r\n\t}\r\n\r\n\t/**\r\n\t * Write reminder of src into dst buffer\r\n\t */\r\n\twf() {\r\n\t\tthis.w(this.src.slice(this.pos))\r\n\t\tthis.pos = this.src.length\r\n\t}\r\n\r\n\tpush() {\r\n\t\tthis.stk.push(this.dst)\r\n\t\tthis.dst = ''\r\n\t}\r\n\r\n\tpop() {\r\n\t\tlet tmp = this.dst\r\n\t\tthis.dst = this.stk.pop()\r\n\t\treturn tmp\r\n\t}\r\n\r\n\tclr() {\r\n\t\tthis.dst = ''\r\n\t}\r\n}\r\n\r\n/**\r\n * Define new macro\r\n * name, formal params, body\r\n * Position of ctx must point to begin of macros name\r\n * if end by @;, then nothing write\r\n * if end by @(..., then write @name(...\r\n * @param ctx\r\n */\r\nexport function defMacro(ctx) {\r\n\tlet c,\r\n\t\tp0 = ctx.pos,\r\n\t\tname = ctx.s('('),\r\n\t\tmacro = new Macros(name)\r\n\r\n\tif (!M1st.test(name[0]))\r\n\t\tctx.err('Invalid macro name', p0)\r\n\r\n\t// Reading the body of the macro\r\n\t// Parameters are read together with the body and parsed each time it is called.\r\n\t// This makes it possible to include the parameters of the parent macro in them.\r\n\tctx.push()\r\n\tbodyPreprocess(ctx)\r\n\tmacro.body = ctx.pop()\r\n\r\n\t// Analysis of the end\r\n\tc = ctx.n()\r\n\tif (c === ';') {\r\n\t\t// Just an ending\r\n\t} else if (c === '(') {\r\n\t\t// End with call macro\r\n\t\tctx.w('@' + name + c)\r\n\t} else {\r\n\t\tctx.err('Invalid macros end')\r\n\t}\r\n\tChemSys.macros[name] = macro\r\n}\r\n\r\n/**\r\n * Define the parameter boundary. The stopper is a sign , or )\r\n * @param {string} src\r\n * @param {number} pos\r\n * @returns {number}\r\n */\r\nexport function scanPar(src, pos) {\r\n\t// balance of parentheses and quotes is very important\r\n\tlet c, lock = 0, bComm = 0\r\n\twhile (pos < src.length) {\r\n\t\tc = src[pos]\r\n\t\tif (c === '\"') bComm = !bComm\r\n\t\telse if (c === '(' && !bComm) lock++\r\n\t\telse if (c === ',' && !bComm && lock === 0) break\r\n\t\telse if (c === ')' && !bComm) {\r\n\t\t\tif (lock > 0) lock--\r\n\t\t\telse break\r\n\t\t}\r\n\t\tpos++\r\n\t}\r\n\treturn pos\r\n}\r\n\r\n/**\r\n * Read parameters list from context\r\n * @param {Ctx} ctx\r\n * @param {string[]} params\r\n * @param {number} offset\r\n */\r\nexport function readRealPars(ctx, params, offset) {\r\n\tctx.pos += offset\r\n\tlet ndx = 0\r\n\tfor(;;) {\r\n\t\tlet p0 = ctx.pos,\r\n\t\t\tp1 = scanPar(ctx.src, p0)\r\n\t\tif (p1 >= ctx.src.length) {\r\n\t\t\tctx.err('Real params list is not closed')\r\n\t\t}\r\n\t\tparams[ndx++] = ctx.n(p1 - p0)\r\n\t\tlet c = ctx.n()\r\n\t\tif (c === ')') break\r\n\t}\r\n}\r\n\r\n/**\r\n * Read formal parameters\r\n * Context position point = position of bracket + 1\r\n * @param {Ctx} ctx\r\n * @param {Object<string,string>} paramsMap\r\n * @param {string[]} paramsIndex\r\n * @param {number=} offset\r\n */\r\nexport function readFormalPars(ctx, paramsMap, paramsIndex, offset = -1) {\r\n\tctx.pos += offset\r\n\tfor (;;) {\r\n\t\tlet k, c, name, posStart = ctx.pos\r\n\t\tlet posFinish = scanPar(ctx.src, posStart)\r\n\t\tif (posFinish >= ctx.src.length)\r\n\t\t\tctx.err('Formal params list is not closed')\r\n\r\n\t\tlet par = ctx.n(posFinish - posStart) // parameter declaration accepted\r\n\t\tk = par.indexOf(':')\r\n\t\tif (k < 0) {\r\n\t\t\t// without default value\r\n\t\t\tname = par\r\n\t\t\tpar = ''\r\n\t\t} else {\r\n\t\t\t// with default value\r\n\t\t\tname = par.slice(0, k)\r\n\t\t\tpar = par.slice(k + 1)\r\n\t\t}\r\n\r\n\t\t// Check parameter name\r\n\t\t// Контролируем правильность описания названия параметра\r\n\t\tif (!TmParam.test(name))\r\n\t\t\tctx.err('Invalid parameter name: ' + esc(name))\r\n\r\n\t\tparamsMap[name] = par\r\n\t\tparamsIndex.push(name)\r\n\t\tc = ctx.n()\r\n\t\tif (c === ')')\r\n\t\t\tbreak\r\n\t}\r\n}\r\n\r\n/**\r\n * Macros execution\r\n * @param {string} src\tMacros with formal params without first (. For example: x,y)&x,&y\r\n * @param {string[]} params\tIndex list of actual parameters, in the text of which there can be names\r\n * This is done because the number of formal parameters is not known exactly before the call\r\n */\r\nexport function execMacros(src, params) {\r\n\tlet ctx = new Ctx(src)\r\n\t// extract formal parameters\r\n\tlet c = ctx.n(), pmap = {}, pndx = []\r\n\tif (c !== ')') {\r\n\t\treadFormalPars(ctx, pmap, pndx)\r\n\t}\r\n\tif (pndx.length > 0) {\r\n\t\tlet k, id, actualParam, i, j = 0\r\n\t\t// Substitute the actual values\r\n\t\tfor (i in params) {\r\n\t\t\tactualParam = params[i]\r\n\t\t\t// If the parameter starts at <param name>:..., then instead of the index, use the name\r\n\t\t\tk = actualParam.indexOf(':')\r\n\t\t\tif (k > 0) {\r\n\t\t\t\tid = actualParam.substring(0, k)\r\n\t\t\t\tif (id in pmap) { // Parameter found to be addressed by key\r\n\t\t\t\t\tpmap[id] = actualParam.slice(k + 1)\r\n\t\t\t\t}\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tid = pndx[j++]\r\n\t\t\tif (actualParam) // The index parameter can be omitted if it is empty. Then the default value will be used instead\r\n\t\t\t\tpmap[id] = actualParam\r\n\t\t}\r\n\t\t// Replace parameters with values\r\n\t\tctx.wf()\r\n\t\tlet chunks = ctx.dst.split('&')\r\n\t\tfor (i = 1; i < chunks.length; i++) {\r\n\t\t\t// Looking for the most suitable parameter\r\n\t\t\tid = ''\r\n\t\t\tfor (actualParam in pmap) {\r\n\t\t\t\tif (chunks[i].slice(0, actualParam.length) === actualParam && actualParam.length > id.length) id = actualParam\r\n\t\t\t}\r\n\t\t\t// If there is a sign & in the formula with which no parameters are associated, skip\r\n\t\t\tif (!id) {\r\n\t\t\t\tchunks[i] = '&' + chunks[i]\r\n\t\t\t} else {\r\n\t\t\t\t// Replace a parameter with a value\r\n\t\t\t\tchunks[i] = pmap[id] + chunks[i].slice(id.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Gathering a new context ...\r\n\t\tctx = new Ctx('')\r\n\t\tchunks.forEach(chunk => ctx.src += chunk)\r\n\t}\r\n\t// Decrypt all macros @A()\r\n\tfor (;;) {\r\n\t\tc = ctx.s('@', true)\r\n\t\tif (c === null) {\r\n\t\t\t// End of macros\r\n\t\t\tctx.wf()\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t// The declaration was found. It can only be a @A\r\n\t\t// The other cases are filtered in bodyPreprocess\r\n\t\tctx.w(c)\r\n\t\tlet name = ctx.s('('),\r\n\t\t\tm = ChemSys.macros[name],\r\n\t\t\tpars = []\r\n\t\tif (!m)\r\n\t\t\tctx.err('Macros not found: ' + name)\r\n\t\t// Извлечение фактических параметров\r\n\t\tc = ctx.n()\r\n\t\tif (c !== ')') {\r\n\t\t\treadRealPars(ctx, pars, -1)\r\n\t\t}\r\n\t\tctx.w(execMacros(m.body, pars))\r\n\t}\r\n\treturn ctx.dst\r\n}\r\n\r\n// Функция, которая ищет конец макроопределения. При этом, на вывод не идут объявления @:\r\n// Конструкция @:A()...@() заменяется на @A()\r\n// Окончание либо по концу буфера, либо по конструкции, отличающейся от @: и @A\r\n/**\r\n * Search the end of macros\r\n * Declarations @: do not output. Instruction @:A()...@() replaced by @A()\r\n * @param {Ctx} ctx\r\n */\r\nexport function bodyPreprocess(ctx) {\r\n\tlet c, plain\r\n\tfor(;;) {\r\n\t\tplain = ctx.s('@', 1)\r\n\t\tif (plain === null) { // макросов больше нет\r\n\t\t\tctx.wf() // пишем остаток строки и заканчиваем обработку\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tctx.w(plain) // Previous text output\r\n\t\tc = ctx.n() // next character\r\n\t\tif (c === ':') {\r\n\t\t\t// new macros declaration\r\n\t\t\tdefMacro(ctx)\r\n\t\t} else if (M1st.test(c)) {\r\n\t\t\t// call to declared macros\r\n\t\t\tctx.w('@' + c)\r\n\t\t\t// continue\r\n\t\t} else {\r\n\t\t\t// Остальные символы расцениваются как окончание тела. их разбор делает вызывающий код\r\n\t\t\tctx.pos--\r\n\t\t\tbreak\r\n\t\t}\r\n\t} // for(;;)\r\n}\r\n\r\n/**\r\n * Preprocess\r\n * @param {string} src\r\n * @returns {string}\r\n * @throws {ChemError}\r\n */\r\nexport function preProcess(src) {\r\n\tlet ctx = new Ctx(src)\r\n\tbodyPreprocess(ctx)\r\n\t// This situation is impossible\r\n\t// if (ctx.pos !== src.length)\r\n\t//\tctx.err('Invalid preprocessor finish')\r\n\r\n\t// execute\r\n\tlet dummyBody = ')' + ctx.dst\r\n\treturn execMacros(dummyBody, [])\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/compiler/preprocess.js","/**\r\n * Created by PeterWin on 08.05.2017.\r\n */\r\n\r\n// Старый формат\r\n//      64\r\n//..32     128\r\n// 16         1\r\n//   8      2\r\n//      4\r\n// Черточки / \\ | . \\  | -_\r\n\r\n/**\r\n * Dashes for item\r\n * @param {string[]} args\r\n * @param {number[]} argsPos\r\n * @param {function} toNum\r\n * @returns {number[]}\r\n */\r\nexport function dashes(args, argsPos, toNum) {\r\n\tlet nextDashes = []\r\n\tlet i, arg = args[0]\r\n\tif (/^[-_.\\/\\\\<>|]+$/.test(arg)) {\r\n\t\tlet dashFlags = 0, c, nu = 0, nm = 0, nd = 0, m\r\n\t\tfor (i = 0; i < arg.length; i++) {\r\n\t\t\tc = arg[i]\r\n\t\t\tswitch (c) {\r\n\t\t\tcase '.':\r\n\t\t\t\tnu++\r\n\t\t\t\tnm++\r\n\t\t\t\tnd++\r\n\t\t\t\tbreak\r\n\t\t\tcase '-':\r\n\t\t\t\tdashFlags |= 64\r\n\t\t\t\tnu++\r\n\t\t\t\tnm++\r\n\t\t\t\tnd++\r\n\t\t\t\tbreak\r\n\t\t\tcase '_':\r\n\t\t\t\tdashFlags |= 4\r\n\t\t\t\tnu++\r\n\t\t\t\tnm++\r\n\t\t\t\tnd++\r\n\t\t\t\tbreak\r\n\t\t\tcase '|':\r\n\t\t\t\tdashFlags |= nm ? 1 : 16\r\n\t\t\t\tnm++\r\n\t\t\t\tbreak\r\n\t\t\tcase '/':\r\n\t\t\t\tdashFlags |= nu ? 2 : 32\r\n\t\t\t\tnu++\r\n\t\t\t\tbreak\r\n\t\t\tcase '\\\\':\r\n\t\t\t\tdashFlags |= nd ? 128 : 8\r\n\t\t\t\tnd++\r\n\t\t\t\tbreak\r\n\t\t\tcase '<':\r\n\t\t\t\tdashFlags |= 40\r\n\t\t\t\tnu++\r\n\t\t\t\tnd++\r\n\t\t\t\tbreak\r\n\t\t\tcase '>':\r\n\t\t\t\tdashFlags |= 130\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (i = 0, m = 1; i < 8; i++, m <<= 1) {\r\n\t\t\tif (m & dashFlags)\r\n\t\t\t\tnextDashes.push(i * 45)\r\n\t\t}\r\n\t} else {\r\n\t\tfor (i in args)\r\n\t\t\tnextDashes.push(toNum(args[i], argsPos[i]))\r\n\t}\r\n\treturn nextDashes\r\n}\r\n\r\nconst SideSyn = { U:'T', D:'B', u:'t', d:'b' },\r\n\tSideMap = { R:0x81, L:0x18, T:0x60, B:0x06 },\r\n\t// Битовые значения для вычёркивания лишнего. По сути = SideMap[i] ^ SubSideMap[i]\r\n\tSubSideMapNeg = { Rt:1, Bl:2, Br:4, Lt:8, Lb:16, Tr:32, Tl:64, Rb:128 }\r\n\r\n/**\r\n * Dots for item\r\n * @param {string[]} args\r\n * @param {number[]} argsPos\r\n * @param {function} toNum\r\n * @returns {number[]}\r\n */\r\nexport function dots(args, argsPos, toNum)\r\n{\r\n\t// Поддерживается 2 формата аргументов:\r\n\t// - UTDBLRutdblr для пар точек сверху, снизу, слева и справа\r\n\t// - список углов\r\n\t// Angles map:\r\n\t// R:0,7;      B:1,2;    L:3,4;    T:5,6  angle = 22.5 + i*45\r\n\t//   1000.0001 0000.0110 0001.1000 0110.0000\r\n\t//    Tl:0x20 Tr:0x40   SubSideMap\r\n\t//  Lt:0x10     Rt:0x80\r\n\t//  Lb:0x08     Rb:0x01\r\n\t//    Bl:0x04 Br:0x02\r\n\tlet nextDots = []\r\n\tlet arg = args[0], i\r\n\tif (/^[!UTBDLR]+$/i.test(arg)) {\r\n\t\t// Старый формат\r\n\t\tlet\tc, s = '', inv = 0, map = 0, m\r\n\t\tfor (i = 0; i < arg.length; i++) {\r\n\t\t\tc = arg[i]\r\n\t\t\tc = SideSyn[c] || c\r\n\t\t\tif (c === '!') {\r\n\t\t\t\tinv = 255\r\n\t\t\t} else if (SideMap[c]) {\r\n\t\t\t\tmap |= SideMap[c]\r\n\t\t\t\ts = c\r\n\t\t\t} else {\r\n\t\t\t\ts += c\r\n\t\t\t\tif (SubSideMapNeg[s]) {\r\n\t\t\t\t\tmap &= ~SubSideMapNeg[s]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tmap ^= inv\r\n\t\tfor (i = 0, m = 1; i < 8; i++, m <<= 1) {\r\n\t\t\tif (m & map)\r\n\t\t\t\tnextDots.push(22.5 + i * 45)\r\n\t\t}\r\n\t} else {\r\n\t\t// list of angles\r\n\t\tfor (i in args) {\r\n\t\t\tnextDots.push(toNum(args[i], argsPos[i]))\r\n\t\t}\r\n\t}\r\n\treturn nextDots\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/compiler/utils.js","/**\r\n * Created by PeterWin on 01.05.2017.\r\n */\r\n'use strict'\r\n\r\nexport default class ChemAgent\r\n{\r\n\tconstructor() {\r\n\t\t/**\r\n\t\t * Nodes\r\n\t\t * @type {ChemNode[]}\r\n\t\t */\r\n\t\tthis.nodes = []\r\n\r\n\t\t/**\r\n\t\t * Bonds\r\n\t\t * @type {ChemBond[]}\r\n\t\t */\r\n\t\tthis.bonds = []\r\n\r\n\t\t/**\r\n\t\t * Commands: nodes, bonds, brackets. Order same as in description\r\n\t\t * Команды: узлы, связи, скобки в том порядке, в котором они следуют в описании\r\n\t\t * @type {Array}\r\n\t\t */\r\n\t\tthis.cmds = []\r\n\r\n\t\t/**\r\n\t\t * Quantity coefficient\r\n\t\t * @type {number|string}\r\n\t\t */\r\n\t\tthis.n = 1\r\n\r\n\t\t/**\r\n\t\t * Index of expression part. For expression H2 + O2 = H2O, H2 and O2 in part 0. H2O in part 1\r\n\t\t * Номер части выражения, в которой находится агент. Если выражение H2 + O2 = H2O, то H2=O2=0, H2O=1\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis.part = 0\r\n\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tlet res, cmd, list = this.cmds\r\n\t\tif (visitor.agentPre) {\r\n\t\t\tres = visitor.agentPre(this)\r\n\t\t\tif (res)\r\n\t\t\t\treturn res\r\n\t\t}\r\n\t\tfor (cmd of list) {\r\n\t\t\tres = cmd.walk(visitor)\r\n\t\t\tif (res)\r\n\t\t\t\tbreak\r\n\t\t}\r\n\t\tif (visitor.agentPost)\r\n\t\t\tres = visitor.agentPost(this) || res\r\n\t\treturn res\r\n\t}\r\n\r\n}\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemAgent.js","/**\r\n * Chemical bond, part of agent\r\n * Created by PeterWin on 30.04.2017.\r\n */\r\n'use strict'\r\n\r\nimport ChemObj from './ChemObj'\r\n\r\nexport default class ChemBond extends ChemObj\r\n{\r\n\tconstructor() {\r\n\t\tsuper()\r\n\t\tthis.index = null\t// index of bond in ChemAgent.bonds array\r\n\t\t// TODO: может быть нарушена в closeAgent при удалении дублирующих связей !!!\r\n\r\n\t\tthis.N = 1\t// multiplicity of the bond\r\n\t\tthis.nodes = [0, 0]\t// nodes\r\n\t\tthis.pt = 0\t\t// bond vector\r\n\t\tthis.tx = ''\t// text description\r\n\t\tthis.slope = 0 // для связи, созданной из описания / = -1, для \\ = 1, для остальных =0\r\n\t\t// Закомментированные поля используются, но не всегда. Для повышения производительности они инициализируются там, где они нужны\r\n\t\t//\tthis.bText = 0;\t// Возможно ли текстовое представление связи\r\n\t\t//\tthis.color = 0;\t// цвет связи\r\n\t\t//\tthis.w0 = 0;\t// Толщина начала линии, 0 для обычной толщины, 1 для жирной\r\n\t\t//\tthis.w1 = 0;\t// толщина конца линии\r\n\t\t//\tthis.bAuto = 0; // Признак связи, пригодной для автокоррекции\r\n\t\t//\tthis.soft = 0;\r\n\t\t//\tthis.style = 0;\t// Строковый стиль линии. Для двойных и тройных связей каждая линия указывается отдельно\r\n\t\t//\tthis.align = 0;\t// Возможные режимы выравнивания двойной связи. x:перекрещенная, m:по центру, l:влево, r:вправо\r\n\t\t//\tthis.arr0 = 0;\t// Стрелка в обратную сторону\r\n\t\t//\tthis.arr1 = 0;\t// Стрелка по направлению линии\r\n\t\t//\tthis.ext = 0;\t// Для _o = 'o', для _s = 's'\r\n\t\t//\tthis.brk = 0;\t// Устанавливается для конструкции типа -#a-#b-#c-, для связи, предшествующей существующему узлу\r\n\t}\r\n\r\n\t/**\r\n\t * Position calculate for second part of bond\r\n\t * @returns {Point}\r\n\t */\r\n\tcalcPt() {\r\n\t\treturn this.nodes[0].pt.addx(this.pt)\r\n\t}\r\n\r\n\t// Получить другой узел\r\n\t/**\r\n\t * Get another node of bond\r\n\t * @param {ChemNode} node\r\n\t * @returns {ChemNode|null}\r\n\t */\r\n\tother(node) {\r\n\t\tlet i = 0, nodes = this.nodes, result\r\n\t\tif (nodes.length === 2) {\r\n\t\t\tresult = nodes[0] === node ? nodes[1] : (nodes[1] === node ? nodes[0] : null)\r\n\t\t} else {\r\n\t\t\tresult = null\r\n\t\t}\r\n\t\treturn result\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tif (visitor.bond)\r\n\t\t\treturn visitor.bond(this)\r\n\t}\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemBond.js","/**\r\n * Brackets\r\n * Created by PeterWin on 06.05.2017.\r\n */\r\nimport ChemObj from './ChemObj'\r\n\r\n// ==================================================\r\n// Begin of bracket\r\n\r\nexport class ChemBrBegin extends ChemObj\r\n{\r\n\tconstructor(text) {\r\n\t\tsuper()\r\n\t\tthis.tx = text\t// Text of open bracket\r\n\t\tthis.end = null\t// pointer to ChemBrEnd\r\n\t\tthis.nodes = [null, null]\r\n\t\tthis.bond = null\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tif (visitor.bracketBegin)\r\n\t\t\treturn visitor.bracketBegin(this)\r\n\t}\r\n}\r\n\r\nChemBrBegin.Map = { '(':')', '[':']', '{(':')}' }\t// Pairs of open and closed brackets\r\n\r\n// ================================================\r\n// End of bracket\r\n\r\nexport class ChemBrEnd extends ChemObj\r\n{\r\n\tconstructor(text, begin) {\r\n\t\tsuper()\r\n\t\tthis.begin = begin\t// pointer to ChemBrBegin\r\n\t\tthis.tx = text\r\n\t\tthis.n = 1\r\n\t\tthis.charge = null\r\n\t\tthis.nodes = [null, null]\r\n\t\tthis.bond = null\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tif (visitor.bracketEnd)\r\n\t\t\treturn visitor.bracketEnd(this)\r\n\t}\r\n}\r\nChemBrEnd.Lst = ')]'\t// Possible bracket\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemBr.js","/**\r\n * Chemical charge\r\n * Created by PeterWin on 28.04.2017.\r\n */\r\n'use strict'\r\n\r\nimport ChemSys from '../ChemSys'\r\n\r\nexport default class ChemCharge\r\n{\r\n\t/**\r\n\t * Attention!\r\n\t * Do not try to call the constructor directly! Use a static function ChemCharge.create()\r\n\t * @constructor\r\n\t */\r\n\tconstructor() {\r\n\t\t/**\r\n\t\t * Text description, for example: '2+'\r\n\t\t * @type {string}\r\n\t\t */\r\n\t\tthis.tx = ''\r\n\r\n\t\t/**\r\n\t\t * number value, for example: 2\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis.val = 0\r\n\r\n\t\t/**\r\n\t\t * ⁺N\r\n\t\t * @type {boolean}\r\n\t\t */\r\n\t\tthis.bLeft = false\r\n\r\n\t\t/**\r\n\t\t * A sign of drawing a charge inside a circle\r\n\t\t * @type {boolean}\r\n\t\t */\r\n\t\tthis.bRound = false\r\n\t}\r\n\r\n\t/**\r\n\t * Create charge object from text description\r\n\t * @param {string} text\tExamples: - + -- ++\r\n\t * @returns {ChemCharge|null}\r\n\t */\r\n\tstatic create(text) {\r\n\r\n\t\tconst makeCharge = (value, bRound, tx) => {\r\n\t\t\tlet charge = new ChemCharge()\r\n\t\t\tcharge.tx = tx || text\r\n\t\t\tcharge.val = +value\r\n\t\t\tcharge.bRound = !!bRound\r\n\t\t\treturn charge\r\n\t\t}\r\n\r\n\t\tif (text && typeof text === 'string') {\r\n\t\t\ttext = text.replace(/–/g, '-')\t// Replace similar characters\r\n\t\t\tlet len = text.length\r\n\t\t\tif (/^-+$/.test(text))\t// One or more minuses:\tO^--\r\n\t\t\t\treturn makeCharge(-len)\r\n\r\n\t\t\tif (/^\\++$/.test(text))\t// One or more pluses: Zn^++\r\n\t\t\t\treturn makeCharge(len)\r\n\r\n\t\t\tif (/(^|(^[-+]))\\d+$/.test(text))\t// A number with a plus or minus front: S^+6, O^-2\r\n\t\t\t\treturn makeCharge(text)\r\n\r\n\t\t\tif (/^\\d+[-+]$/.test(text))\t\t// A number with plus or minus behind: Ca^2+, PO4^3-\r\n\t\t\t\treturn makeCharge(text.charAt(len - 1) + text.slice(0, -1))\r\n\r\n\t\t\tif (text == '+o') {\r\n\t\t\t\treturn makeCharge(1, 1, '+')\r\n\t\t\t}\r\n\t\t\tif (text == '-o') {\r\n\t\t\t\treturn makeCharge(-1, 1, '-')\r\n\t\t\t}\r\n\t\t\tvar v = ChemSys.RomanNum[text]\r\n\t\t\tif (v) {\r\n\t\t\t\ttext = text.toUpperCase()\r\n\t\t\t\treturn makeCharge(v)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemCharge.js","/**\r\n * Comment\r\n * For example \"Anion\"-SO4^2-\r\n * Created by PeterWin on 29.04.2017.\r\n */\r\n'use strict'\r\n\r\nimport ChemSubObj from './ChemSubObj'\r\n\r\nexport default class ChemComment extends ChemSubObj\r\n{\r\n\t/**\r\n\t * @constructor\r\n\t * @param {string} text\r\n\t */\r\n\tconstructor(text) {\r\n\t\tsuper()\r\n\t\tthis.tx = text\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tif (visitor.comm)\r\n\t\t\treturn visitor.comm(this)\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemComment.js","/**\r\n * Abstract component\r\n * For example: {R}-OH\r\n * Created by PeterWin on 29.04.2017.\r\n */\r\n\"use strict\"\r\n\r\nimport ChemSubObj from './ChemSubObj'\r\n\r\nexport default class ChemCustom extends ChemSubObj\r\n{\r\n\t/**\r\n\t * @constructor\r\n\t * @param {string} text\t\tText content of abstract component\r\n\t */\r\n\tconstructor(text) {\r\n\t\tsuper()\r\n\t\tthis.tx = text\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tif (visitor.custom)\r\n\t\t\treturn visitor.custom(this)\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemCustom.js","/**\r\n * Chemical expression\r\n * Created by PeterWin on 28.04.2017.\r\n */\r\n'use strict'\r\n\r\nimport ChemObj from './ChemObj'\r\nimport IsNonText from '../visitors/IsNonText'\r\nimport TextMaker from '../visitors/TextMaker'\r\n\r\nexport default class ChemExpr extends ChemObj\r\n{\r\n\tconstructor() {\r\n\t\tsuper()\r\n\r\n\t\t/**\r\n\t\t * Error\r\n\t\t * @type {ChemError}\r\n\t\t */\r\n\t\tthis.error = null\r\n\r\n\t\t/**\r\n\t\t * Source description\r\n\t\t * @type {string}\r\n\t\t */\r\n\t\tthis.src0 = ''\r\n\r\n\t\t/**\r\n\t\t * Description after preprocessing\r\n\t\t * @type {string}\r\n\t\t */\r\n\t\tthis.src = ''\r\n\r\n\t\t/**\r\n\t\t * Entities: reagents and operations\r\n\t\t * @type {Array}\r\n\t\t */\r\n\t\tthis.ents = []\r\n\t}\r\n\r\n\t/**\r\n\t * Check for success. If false, then an error.\r\n\t * @returns {boolean}\r\n\t */\r\n\tisOk() {\r\n\t\treturn !this.error\r\n\t}\r\n\r\n\t/**\r\n\t * Extended error message. Empty string, if not error\r\n\t * @returns {string}\r\n\t */\r\n\tgetMessage() {\r\n\t\treturn this.error ? this.error.getMessage() : ''\r\n\t}\r\n\r\n\t/**\r\n\t * Bypass the whole structure\r\n\t * @param {Object} visitor\r\n\t * @returns {*}\r\n\t */\r\n\twalk(visitor) {\r\n\t\tlet res, entity, entitiesList = this.ents,\r\n\t\t\tpre = visitor.entityPre,\r\n\t\t\tpost = visitor.entityPost\r\n\r\n\t\tfor (entity of entitiesList) {\r\n\t\t\tif (pre)\r\n\t\t\t\tres = visitor.entityPre(entity)\r\n\r\n\t\t\tres = res || entity.walk(visitor)\r\n\r\n\t\t\tif (post)\r\n\t\t\t\tres = visitor.entityPost(entity) || res\r\n\r\n\t\t\tif (res)\r\n\t\t\t\treturn res\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Convert expression to html\r\n\t * This shell for TextMaker visitor\r\n\t * @param {Object<string,string>} rules\r\n\t * @returns {string}\r\n\t */\r\n\thtml(rules) {\r\n\t\tif (this.isLinear()) {\r\n\t\t\tlet textMaker = new TextMaker(rules)\r\n\t\t\tthis.walk(textMaker)\r\n\t\t\treturn textMaker.res()\r\n\t\t} else {\r\n\t\t\treturn ''\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Convert expression to text\r\n\t * This shell for TextMaker visitor\r\n\t * @param {Object<string,string>} rules\t\tdefault value='text', u can use ChemSys.rulesHTML\r\n\t * @returns {string}\r\n\t */\r\n\ttext(rules = 'text') {\r\n\t\treturn this.html(rules)\r\n\t}\r\n\r\n\t/**\r\n\t * Get source code for object\r\n\t * (Text after preprocess)\r\n\t * @returns {string}\r\n\t */\r\n\tgetObjSrc(obj) {\r\n\t\treturn this.src.slice(obj.pA, obj.pB)\r\n\t}\r\n\r\n\t// Является ли формула линейной (т.е. может быть представлена в виде html-текста)\r\n\t// добавлена для удобства и совместимости с предыдущей версией\r\n\tisLinear() {\r\n\t\tlet isNonText = new IsNonText()\r\n\t\tthis.walk(isNonText)\r\n\t\treturn !isNonText.ok\r\n\t}\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemExpr.js","/**\r\n * Created by PeterWin on 08.05.2017.\r\n */\r\n'use strict'\r\n\r\nimport ChemObj from './ChemObj'\r\n\r\n// Начало конструкции, умножающей последующее содержимое на указанный коэффициент\r\n// Кроме того, является мостиком, т.е. образует новую подцепь\r\n// example: CuSO4*5H2O\r\nexport default class ChemMul extends ChemObj {\r\n\tconstructor(n) {\r\n\t\tsuper()\r\n\t\tthis.n = n\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tif (visitor.mul)\r\n\t\t\tvisitor.mul(this)\r\n\t}\r\n}\r\n\r\n// Конец множителя.\r\n// Не участвует в выводе. Предназначен для вычислительных алгоритмов, использующих стек, чтобы выполнить pop\r\nexport class ChemMulEnd extends ChemObj {\r\n\tconstructor(begin) {\r\n\t\tsuper()\r\n\t\tthis.beg = begin\r\n\t\tthis.n = begin.n\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tif (visitor.mulEnd)\r\n\t\t\tvisitor.mulEnd(this)\r\n\t}\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemMul.js","/**\r\n * Node is a part of reagent.\r\n * For example, CH3-CH2-OH contains 3 nodes\r\n * Created by PeterWin on 30.04.2017.\r\n */\r\n\r\nimport Point from '../math/Point'\r\n\r\nexport default class ChemNode\r\n{\r\n\tconstructor(pt = new Point()) {\r\n\t\tthis.index = null\t// index of node in CAgent.nodes array\r\n\t\tthis.pt = pt\t// node coordinates in subchain\r\n\t\tthis.ch = 0\t\t// chain number\r\n\t\tthis.sc = 0\t\t// subchain number\r\n\t\tthis.bAuto = false\t// auto node\r\n\t\tthis.fixed = false\t// fixed node\r\n\r\n\t\t/**\r\n\t\t * node charge\r\n\t\t * @type {ChemCharge}\r\n\t\t */\r\n\t\tthis.charge = null\r\n\r\n\t\t/**\r\n\t\t * Example: node CH4 contains 2 items\r\n\t\t * @type {ChemNodeItem[]}\r\n\t\t */\r\n\t\tthis.items = []\r\n\r\n\t\t/**\r\n\t\t * bonds, what contains this node\r\n\t\t * @type {ChemBond[]}\r\n\t\t */\r\n\t\tthis.bonds = []\r\n\t}\r\n\r\n\t/**\r\n\t * get number charge value\r\n\t * @returns {number}\r\n\t */\r\n\tchargeVal() {\r\n\t\treturn this.charge ? this.charge.val : 0\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tlet res, i = 0, lst = this.items\r\n\t\tif (visitor.nodePre) {\r\n\t\t\tres = visitor.nodePre(this)\r\n\t\t\tif (res)\r\n\t\t\t\treturn res\r\n\t\t}\r\n\t\twhile (i < lst.length && !res) {\r\n\t\t\tres = lst[i++].walk(visitor)\r\n\t\t}\r\n\t\tif (visitor.nodePost)\r\n\t\t\tres = visitor.nodePost(this) || res\r\n\t\treturn res\r\n\t}\r\n\r\n}\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemNode.js","/**\r\n * Item of node\r\n * This is shell, containing internal object. Usually, ChemAtom\r\n * NodeItem have koefficient and charge\r\n * Created by PeterWin on 29.04.2017.\r\n */\r\n\"use strict\"\r\n\r\nimport ChemObj from './ChemObj'\r\n\r\nexport default class ChemNodeItem extends ChemObj\r\n{\r\n\t/**\r\n\t * @constructor\r\n\t * @param {ChemSubObj} obj\r\n\t */\r\n\tconstructor(obj) {\r\n\t\tsuper()\r\n\t\t/**\r\n\t\t * sub object\r\n\t\t * @type {ChemSubObj}\r\n\t\t */\r\n\t\tthis.obj = obj\r\n\r\n\t\t/**\r\n\t\t * Koefficient. Can be string for abstract component H'n'\r\n\t\t * @type {number|string}\r\n\t\t */\r\n\t\tthis.n = 1\r\n\r\n\t\t/**\r\n\t\t * Charge\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis.charge = 0\r\n\r\n\t\t/**\r\n\t\t * Special mass.\r\n\t\t * If specified, then ignore mass of sub object\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis.M = 0\r\n\r\n\t\t//this.atomNum = 0;\t//0/1 - признак вывода атомного номера (для ядерных реакций)\r\n\t\t//this.color = 0;\t// общий цвет\r\n\t\t//this.atomColor = 0;\t// цвет атомов\r\n\t\t//this.bCenter = 0;\t// Необяз. признак приоритетности элемента, задаваемый при помощи обратного апострофа: H3C`O|\r\n\t\t//this.dots = [];\r\n\t\t//this.dashes = [];\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tlet res;\r\n\t\tif (visitor.itemPre) {\r\n\t\t\tres = visitor.itemPre(this)\r\n\t\t\tif (res)\r\n\t\t\t\treturn res\r\n\t\t}\r\n\t\tres = this.obj.walk(visitor);\r\n\t\tif (visitor.itemPost)\r\n\t\t\tres = visitor.itemPost(this) || res;\r\n\t\treturn res;\r\n\t}\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemNodeItem.js","/**\r\n * Chemical operation\r\n *     commentPre\r\n * CaCO3 --> CaO + CO2\r\n *     commentPost\r\n * Created by PeterWin on 01.05.2017.\r\n */\r\n\r\nimport ChemObj from './ChemObj'\r\n\r\nexport default class ChemOp extends ChemObj\r\n{\r\n\t/**\r\n\t * @constructor\r\n\t * @param {string=} srcText, for example ->\r\n\t * @param {string=} dstText, for ex →\r\n\t * @param {boolean=false} bEq\tsign of equation operation (=, ->, <=>)\r\n\t */\r\n\tconstructor(srcText, dstText, bEq) {\r\n\t\tsuper()\r\n\t\tthis.srcText = srcText\r\n\t\tthis.dstText = dstText\r\n\t\tthis.eq = !!bEq\r\n\t\t//this.commentPre=0;\t// ChemComment objects\r\n\t\t//this.commentPost=0;\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tif (visitor.operation)\r\n\t\t\treturn visitor.operation(this)\r\n\t}\r\n}\n\n\n// WEBPACK FOOTER //\n// src/core/ChemOp.js","/**\r\n * Chemical radical\r\n * Created by PeterWin on 29.04.2017.\r\n */\r\n'use strict'\r\n\r\nimport ElemList, { ElemRec } from './ElemList'\r\n\r\nexport default class ChemRadical\r\n{\r\n\t/**\r\n\t * @constructor\r\n\t * @param {string} label\r\n\t * @param {ElemList} elemsList\r\n\t */\r\n\tconstructor(label, elemsList) {\r\n\t\tthis.label = label\t\t// radical label\r\n\t\tthis.items = elemsList\t// list of records {id,elem, n} (=ElemList)\r\n\t}\r\n\r\n\twalk(visitor) {\r\n\t\tif (visitor.radical)\r\n\t\t\treturn visitor.radical(this)\r\n\t}\r\n\r\n\tstatic get Map() {\r\n\t\tif (!isMapInit) {\r\n\t\t\tinitMap()\r\n\t\t}\r\n\t\treturn chemRadicalMap\r\n\t}\r\n}\r\n\r\n//======= radicals list\r\nconst radicals = [\r\n\t'Me:C,H*3',\r\n\t'Et:C*2,H*5',\r\n\t'Ph:C*6,H*5',\r\n\t'Pr,n-Pr,Pr-n:C*3,H*7',\r\n\t'iPr,i-Pr,Pr-i:C*3,H*7',\r\n\t'Bu,nBu,n-Bu,Bu-n:C*4,H*9',\r\n\t'i-Bu,Bu-i:C*4,H*9',\r\n\t'Ac:C,H*3,C,O'\r\n]\r\n\r\n\r\n/**\r\n * Radicals dictionary\r\n * @type {Object<string, ChemRadical>}\tid=>ChemRadical\r\n */\r\nlet chemRadicalMap = {}\r\n\r\nlet isMapInit = false\r\n\r\nconst initMap = () => {\r\n\tisMapInit = true\r\n\tradicals.forEach(descr => {\r\n\t\tlet L = descr.split(':'),\r\n\t\t\telemList = new ElemList(),\r\n\t\t\tids = L[0].split(','),\r\n\t\t\telems = L[1].split(',')\r\n\t\telems.forEach(elem => {\r\n\t\t\tlet e = elem.split('*')\r\n\t\t\telemList.addElemRec(new ElemRec(e[0], e[1] ? +e[1] : 1))\r\n\t\t})\r\n\t\tids.forEach( id => {\r\n\t\t\tchemRadicalMap[id] = new ChemRadical(id, elemList)\r\n\t\t})\r\n\r\n\t})\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/core/ChemRadical.js"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChEA;;;AAGA;AACA;;;;AAeA;AACA;AAfA;AACA;AAAA;AACA;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;;;AACA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AASA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AC/LA;;;;;AAKA;AACA;;;;;;;;;AACA;AAEA;;;;;AAKA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;;;;;AAfA;;;;;;;ACPA;;;AAGA;AACA;;;;;;AACA;AACA;;;;;AACA;;;;;AAKA;AAAA;AAAA;AACA;AAEA;;;;;AAKA;AAAA;AAAA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AACA;;;;;AAKA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;ACxFA;;;;;AAKA;;;;AAAA;;;;;;;ACLA;;;;AAIA;AACA;;;;;;;AACA;AACA;;;;;;;;;;;AACA;;;AAEA;;;;;;AAMA;AAAA;AACA;AADA;AACA;AACA;AACA;AACA;AAJA;AAKA;AACA;AACA;;;;;;;;AAIA;AACA;AAEA;;;;;;AAtBA;;;;;;;;;;;;ACFA;AACA;AAHA;AACA;;;;;AACA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC3KA;;;;AAIA;AACA;;;;;;;AACA;AACA;;;;;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;;;AAOA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;AACA;;;;AAIA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5EA;AACA;AA8EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhGA;AAkGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAnGA;AACA;AA8HA;;;;;;;ACvNA;;;AAGA;AACA;;;;;AACA;AACA;;;;;AACA;AACA;AAAA;AACA;AACA;;;;;;AAMA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1BA;;;;;;AAMA;AACA;;;;;;;;AACA;AACA;;;;;;;;;;;AACA;AACA;AACA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;;;;;;AAKA;;;AAEA;AAAA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AAAA;AAAA;AACA;AAGA;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAGA;;;;AAIA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AArKA;AAsKA;AACA;;AAzKA;AACA;AA2KA;;;;;;;ACzNA;;;;AAIA;AACA;;;;;;;;;AACA;AACA;AACA;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AASA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;;AASA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAjWA;AACA;AACA;;;AA+TA;AACA;AACA;;;;;;AAzVA;;;;;;;;;;;;;;;;;ACNA;;;;AAIA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;;;AAAA;AACA;AACA;AACA;;;;;;AAPA;;;;;;;ACNA;;;;;AAKA;AACA;;;;AA6IA;AACA;AA7IA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;AAAA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AACA;AA0BA;AACA;AAcA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AADA;AAIA;AACA;AADA;AAIA;AACA;AADA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;;;;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AAJA;AAKA;AALA;AAAA;AAQA;AARA;AAAA;AAUA;AAVA;AAWA;AAXA;AAYA;AAZA;AAaA;AAbA;AACA;AAcA;AAfA;AAgBA;AAhBA;AAiBA;AAjBA;AAkBA;AAlBA;AAmBA;AAnBA;AAoBA;AApBA;AAqBA;AArBA;AAsBA;AAtBA;AAAA;AAwBA;AAxBA;AAyBA;AAzBA;AACA;AA0BA;AA3BA;AA4BA;AA5BA;AA6BA;AA7BA;AACA;AA8BA;AA/BA;AAgCA;AAhCA;AAiCA;AAjCA;AAAA;AACA;AAsCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAHA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAtDA;AACA;AAyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzDA;AA2DA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA5BA;AA8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1MA;AACA;AA4MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzxDA;AAhBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAAA;AACA;AAEA;;;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChDA;;;AAGA;AACA;;;;AAkBA;AACA;AAnBA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AAAA;AACA;AAEA;;;;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChEA;AACA;AATA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;;;;;;AAMA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;;;;AAhEA;;;;;;;AClBA;;;;;AAKA;AACA;AACA;;;;;;;;;;;AAIA;AAsEA;AACA;;;AAvEA;AAAA;AACA;AAAA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AAAA;AAAA;AACA;AACA;;;;AAIA;AAAA;AACA;AAAA;AADA;AACA;AAEA;;;;;AAKA;AAAA;AACA;AAAA;AADA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;AAKA;AAAA;AAAA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AAAA;AAAA;AACA;AACA;;;;AAIA;AAAA;AAAA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AAEA;;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAlGA;;;;;;;;;;;;;;;;ACrDA;AAmCA;AAuBA;AAuBA;AAuCA;AAgFA;AA+BA;AACA;AAvWA;AACA;;;AAAA;AACA;;;;;AALA;;;;;AAMA;AACA;;;;AADA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;AAKA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAEA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;;;;AAGA;;;;;;;;;;AAQA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChWA;AAsEA;AAzFA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArCA;AAuCA;AACA;AACA;AAEA;AACA;AACA;AACA;AADA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrIA;;;AAGA;AACA;;;;;;;;;AACA;AAEA;AAAA;AACA;AAAA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;AAKA;AAEA;AACA;;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AANA;AAAA;AAAA;AACA;AADA;AAOA;AAAA;AACA;AAAA;AACA;AAEA;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAWA;AAEA;AACA;;;;;;AApDA;;;;;;;ACLA;;;;AAIA;AACA;;;;;;;AACA;AACA;;;;;;;;;;;AACA;;;AAEA;AAAA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;AAuBA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AAEA;;;;;;AAtDA;;;;;;;;;;;;;;;;ACJA;AACA;;;;;;;;;AALA;;;;;;AAMA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AACA;;;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAQA;AACA;;;AACA;AACA;AAEA;;;;;;AAEA;;;;;;;AC/CA;;;;AAIA;AACA;;;;;;;AACA;AACA;;;;;;;AACA;AAEA;;;;;AAKA;AAAA;AACA;AAAA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AA5EA;;;;;;;ACRA;;;;;AAKA;AACA;;;;;;;AACA;AACA;;;;;;;;;;;AACA;;;AAEA;;;;AAIA;AAAA;AACA;AADA;AACA;AACA;AAFA;AAGA;AACA;;;AACA;AACA;AAEA;;;;;;AAdA;;;;;;;ACTA;;;;;AAKA;AACA;;;;;;;AACA;AACA;;;;;;;;;;;AACA;;;AAEA;;;;AAIA;AAAA;AACA;AADA;AACA;AACA;AAFA;AAGA;AACA;;;AACA;AACA;AAEA;;;;;;AAdA;;;;;;;ACTA;;;;AAIA;AACA;;;;;;;AACA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;;;;;;;;;AACA;;;AAEA;AAAA;AACA;AAEA;;;;AAHA;AACA;AAMA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AAzBA;AA0BA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AACA;AADA;AAKA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AA/GA;;;;;;;ACVA;;;AAGA;AACA;;;;;;;;AACA;AACA;;;;;;;;;;;AACA;AACA;AACA;AACA;;;AACA;AAAA;AACA;AADA;AACA;AACA;AAFA;AAGA;AACA;;;AACA;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AAfA;AACA;AAaA;;;AACA;AAAA;AACA;AADA;AACA;AACA;AACA;AAHA;AAIA;AACA;;;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;AClCA;;;;;;AAMA;AACA;;;;;;;AACA;AAEA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;;;;;;;AAIA;AACA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;AAlDA;;;;;;;ACRA;;;;;;AAMA;AACA;;;;;;;AACA;AACA;;;;;;;;;;;AACA;;;AAEA;;;;AAIA;AAAA;AACA;AACA;;;;AAFA;AACA;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhCA;AAiCA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;AApDA;;;;;;;;;;;;;;;ACFA;AACA;;;;;;;;;AATA;;;;;;;;AAUA;;;AAEA;;;;;;AAMA;AAAA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAOA;AACA;;;AACA;AACA;AAEA;;;;;;AApBA;;;;;;;ACVA;;;;AAIA;AACA;;;;;;;AACA;AACA;;;;;;;AACA;AAEA;;;;;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AACA;AAEA;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AA3BA;AA0BA;AACA;AAWA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;A","sourceRoot":""}